[{"content":" 筆記  部落格要一直寫下去是不間單，工作一忙回到家倒頭就睡，沒時間跟精神來記錄一下\n我本人基本上沒有在使用IG，但內心也有一個要發廢文的衝動\n把這邊當IG在用來的心態寫東西\n記錄一下Hugo操作的指令\n免得下次又要再去查怎麼用\n Hugo指令  新增文章 hugo new post/20220928_Blog操作手冊.md 這樣就可以在content/post/下看到新創的markdown檔\n開幾本地server hugo server 先在本地測試預覽用的\n打包成靜態網頁檔 hugo hugo -d ../GitHub/MindBreaker3310.github.io 執行完後，打包的靜態網頁會輸出在public/資料夾下\n或是給他destination flag輸出到指定資料夾\n GitHub Page相關  我這邊是打包成靜態網頁檔直接蓋掉Github Page對應在本機的檔案\n接著commit push收工\n MarkDown相關  \u0026gt;## MarkDown相關\n段落標題，如上\n### 段落內的小區塊\n段落內的小區塊 **就是粗體** *就是斜體*\n就是粗體 就是斜體\n+ 列表的Fu\n 列表的Fu  ![圖片下方的文字](images/圖片檔名.jpg)\n\r上圖片\r\n其他有需要再去查吧 https://markdown.tw/\n 後記  希望未來還能持續更新，GOGO~\n","date":"2022-09-28T14:24:26+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20220928_blog%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8A.md/","title":"Blog操作手冊"},{"content":" 前言  之前寫了關於RabbitMQ的筆記\n其實是記錄如何使用masstransit套件來快速的傳遞message\n這個套件支援的功能與能夠設定的細節當然是沒有原生來得好\n所以重新學習一下如何使用官方的套件\n Hello World!  實作最簡單的\nProducer直接將Message丟入Queue再由Consumer處理完畢\n\r架構圖\r\n 發送端程式碼  class Send { public static void Main() { var factory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; }; using (var connection = factory.CreateConnection())//連線至rabbitmq server  using (var channel = connection.CreateModel())//建立模型  { //宣告queue(如果不存在才會宣告)  channel.QueueDeclare(queue: \u0026#34;hello\u0026#34;,//queue名稱  durable: false, exclusive: false, autoDelete: false, arguments: null); //要傳送的訊息  string message = \u0026#34;Hello World!\u0026#34;; var body = Encoding.UTF8.GetBytes(message); //傳送至queue  channel.BasicPublish(exchange: \u0026#34;\u0026#34;, routingKey: \u0026#34;hello\u0026#34;,//queue名稱  basicProperties: null, body: body); Console.WriteLine(\u0026#34; [x] Sent {0}\u0026#34;, message); } Console.WriteLine(\u0026#34; Press [enter] to exit.\u0026#34;); Console.ReadLine(); } }  接收端程式碼  class Receive { public static void Main() { var factory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; }; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { channel.QueueDeclare(queue: \u0026#34;hello\u0026#34;, durable: false, exclusive: false, autoDelete: false, arguments: null); //建立Consumer  var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =\u0026gt; //ea = EventArgs  { var body = ea.Body.ToArray(); var message = Encoding.UTF8.GetString(body); Console.WriteLine(\u0026#34; [x] Received {0}\u0026#34;, message); }; //回傳Ack  channel.BasicConsume(queue: \u0026#34;hello\u0026#34;, autoAck: true, consumer: consumer); Console.WriteLine(\u0026#34; Press [enter] to exit.\u0026#34;); Console.ReadLine(); } } }  Work queues  發送端基本一樣，但是可以有多個接收端，避免被單一個Consumer卡住\n\r架構圖\r\n 發送端程式碼  class NewTask { public static void Main(string[] args) { var factory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; }; using (var connection = factory.CreateConnection())//連線至rabbitmq server  using (var channel = connection.CreateModel())//建立模型  { //宣告queue(如果不存在才會宣告)  channel.QueueDeclare(queue: \u0026#34;task-queue\u0026#34;, durable: true,//重開RabbitMQ仍會存在  exclusive: false, autoDelete: false, arguments: null); //要傳送的訊息  var message = GetMessage(args); var body = Encoding.UTF8.GetBytes(message); //傳送至queue  channel.BasicPublish(exchange: \u0026#34;\u0026#34;, routingKey: \u0026#34;task-queue\u0026#34;,//queue名稱  basicProperties: null, body: body); Console.WriteLine(\u0026#34; [x] Sent {0}\u0026#34;, message); } Console.WriteLine(\u0026#34; Press [enter] to exit.\u0026#34;); Console.ReadLine(); } private static string GetMessage(string[] args) { //如果輸入參數為空，代入Hello World!  return args.Length \u0026gt; 0 ? string.Join(\u0026#34; \u0026#34;, args) : \u0026#34;Hello World!\u0026#34;; } } 這裡宣告的Queue durable是true，所以當RabbitMQ server重開後，仍會存在。\n 接收端程式碼  class Worker { public static void Main(string[] args) { var factory = new ConnectionFactory() { HostName = \u0026#34;localhost\u0026#34; }; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { channel.QueueDeclare(queue: \u0026#34;task-queue\u0026#34;, durable: true, exclusive: false, autoDelete: false, arguments: null); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =\u0026gt; { var body = ea.Body.ToArray(); var message = Encoding.UTF8.GetString(body); Console.WriteLine(\u0026#34; [x] Received {0}\u0026#34;, message); //增加延遲  int dots = message.Split(\u0026#39;.\u0026#39;).Length - 1; Thread.Sleep(dots * 1000); Console.WriteLine(\u0026#34; [x] Done\u0026#34;); //處理中返回錯誤訊息  //channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);  }; //告入rabbitMQ 已經處理完畢，可以釋放空間。  channel.BasicConsume(queue: \u0026#34;hello\u0026#34;, autoAck: true, consumer: consumer); //錯誤的話  //channel.BasicConsume(queue: \u0026#34;hello\u0026#34;,  // autoAck: false,  // consumer: consumer);  Console.WriteLine(\u0026#34; Press [enter] to exit.\u0026#34;); Console.ReadLine(); } } }  參考  ","date":"2022-07-06T15:04:29+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20220706_rabbitmq%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3.md/","title":"RabbitMQ重新理解"},{"content":" 筆記  記錄一下這個特別的controller寫法\n通通都只有一個入口，傳入加密的電文，解析電文後\n會得知要執行的class名稱與DLL名稱\n由名稱字串到執行功能的步驟\n來做到動態的呼叫的方法\n使用反射\n不囉說 直接看程式\n//xxxService 專案名稱 //xxxFolder 資料夾名稱 //xxxClass 名稱 //\u0026#34;xxxClass的位置, DLL名稱(通常是專案名稱)\u0026#34; string targetFile = \u0026#34;xxxService.xxxFolder.xxxClass, xxxService\u0026#34;; //方法名稱 string targetMethod = \u0026#34;DoSomething\u0026#34;; //傳入參數 Object[] args = [{xxxInputObject}]; //讀取dll Type dll = Type.GetType(target); //實作dll Object InstanceObj = dll.InvokeMember(null, BindingFlags.DeclaredOnly | //invokeAttr一個或多個BindingFlags組成，會指定執行搜尋的方式  BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.CreateInstance, null, null, null); //執行實作物件的方法 Object result = dll.InvokeMember(targetMethod,//要呼叫的屬性或方法名稱  BindingFlags.InvokeMethod, //invoke參數  null, InstanceObj, //要執行的obj  args); //傳入的參數  //回傳執行結果 return result;  參考  https://www.dotblogs.com.tw/joysdw12/2012/09/13/74761\n","date":"2022-06-29T10:48:46+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20220629_c#%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E7%B4%80%E9%8C%84.md/","title":"C#反射方法紀錄"},{"content":" 筆記  還不會在dcoker內透過mongo express(GUI工具)同時連線多個MongoDB，只能先用指令先擋著了。\n常用查看資料內容的方法大致如下\n其他用在再看文檔就好\n//使用mongo cli mongo //顯示資料庫 show dbs //使用資料庫(myDb為例) use myDb //讀取資料 db.myCollection.find() db.myCollection.find().pretty() db.get(\u0026#39;myCollection\u0026#39;).find() db.get(\u0026#39;myCollection\u0026#39;).find().pretty() //有條件的讀取 db.myCollection.find({條件}, {欄位}) db.myCollection.find({name: \u0026#39;Max\u0026#39;}, {name : 1, age : 1}) db.myCollection.find({name: \u0026#39;Max\u0026#39;}, {name : 1, age : 1, height : 1}) // \u0026gt;18歲 db.myCollection.find({age: {$gt : 18} }, {name : 1, age : 1}) // \u0026gt;=18歲 db.myCollection.find({age: {$gte : 18} }, {name : 1, age : 1}) // \u0026lt;18歲 db.myCollection.find({age: {$lt : 18} }, {name : 1, age : 1}) // \u0026lt;=18歲 db.myCollection.find({age: {$lte : 18} }, {name : 1, age : 1})  參考  https://www.mongodb.com/docs/v4.4/crud/\nhttps://www.runoob.com/mongodb/mongodb-operators.html\n","date":"2022-06-27T14:07:21+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20220627_mongodb_cli%E6%93%8D%E4%BD%9C.md/","title":"MongoDb Cli 讀取資料"},{"content":" 筆記  老闆最近希望讓我去開發與設計一個管理公司內部合約與公文的檔管系統\n以前在學校學習的已經還給老師啦XD\n趁這個機會複習一下\n一個系統開發不只包含了coding也同時有設計、品管、預算、測試、寫文件、上線與維護\n常用的開發流程分為Waterfall與Agile\n Waterfall  Waterfall最適合幾乎確定需求且開發中不會有太多變動\n主要可以分為五個步驟\n 收集與分析需求 決定系統架構 實作 驗證 維護   收集與分析需求 與利益相關者保持距離並徹底紀錄需求\n下面已建立note app為例\n可以使用“必須”來條列式需求\n  功能需求：\n APP必須可以記錄文字，也可以插入圖片或手寫塗鴉。 部分筆記內容必須設定密碼，避免被別人看見。 筆記內容必須可以自動同步到雲端硬碟上。    非功能性需求：\n 必須支援ios10或更新版 必須減少不必要的資料傳輸，以降低伺服器的負擔    從功能需求我們可以分析出三個情境(epic)\n 筆記的建立與編輯 隱私問題 雲端同步    情境1：筆記建立與編輯\n 身為一個user，我要可以快速記下筆記。 身為一個user，我要能把圖片以附件的方式附上，避免影響到筆記的排版。 身為一個user，我要有手寫功能，讓我的筆記更有溫度。    情境2：隱私\n 身為一個user，我要建立隱私筆記，只有我能存取它。 身為一個user，我要用密碼保護我的隱私筆記。    情境3：雲端同步\n 身為一個user，我要打開app時，資料就已經同步成最新版。 身為一個user，我要能夠自動同步到雲端硬碟上，隨時備份不怕資料不見。    依照情境畫出Use Cases圖\n\r筆記建立與編輯\r\n\r隱私\r\n\r雲端同步\r\n畫出class之間的關聯圖\n畫出流程圖\n 決定系統架構 這個步驟就像是建築的藍圖一樣，設計必須清晰明瞭\n 要用什麼package/components？ 每個component的type是什麼？ 這些type怎麼互動或達成功能所需 我們的系統安全嗎？ 效能如何？ 如何處理錯誤？ 我們的系統穩固嗎？ 之後會不會擴展？ 使用哪些第三方套件？   實作＆測試 就是實作，發與測試，平常在做的。\n交給User測試功能性、安全性、效能、實用性\n這兩個步驟會一直重複到沒有bug\n 維護 在這個階段就是抓抓小蟲\n小幅度強化功能\n Agile  敏捷開發是為了因應需求一直變動，沒辦法再開發之前就知道最終的產品會是長什麼樣子，透過不斷重複的週期(Sprint)循環，每次都一點點收集分析資料、設計、實作、測試，每一個循環就像小瀑布一樣。\n常聽到的Scrum就是一種實作Agile的方式\n","date":"2022-01-26T13:31:49+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20220126%E5%AD%B8%E7%BF%92uml.md/","title":"學習UML"},{"content":" 筆記  Api Gateway的設計有好幾種，通常來說一般只用一個Api Gw來當一個入口並不是個好主意，可以設計成SPA網頁用一個、手機App用一個、傳統網站用一個。\n這邊使用的Api Gw是Ocelot\nOcelot是一個輕量化、容易擴充、開源的專案👍\n 前置作業  開啟新專案 \u0026raquo; Empty .Net Project\nNuGet安裝必要套件Ocelot\n如果要使用快取功能的話，還要安裝Ocelot.Cache.CacheManager\n 註冊與使用Ocelot服務 要使用快取功能才要加上AddCacheManager\npublic void ConfigureServices(IServiceCollection services) { services.AddOcelot() .AddCacheManager(settings =\u0026gt; settings.WithDictionaryHandle()); } public async void Configure(IApplicationBuilder app, IWebHostEnvironment env) { //前略...  await app.UseOcelot(); }  建立閘道路由json檔案 建立一個類似appsettings.json依照環境是Development還是Debug來覆寫的檔案\n celot.json(維持空的)  ocelot.Development.json ocelot.Local.json(本地測試)    依照命名VS會自動合併\n專案的環境變數ASPNETCORE_ENVIRONMENT要設定成Local\n 設定Program.cs public static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureAppConfiguration((hostingContext, config) =\u0026gt; { //會依照ASPNETCORE_ENVIRONMENT來讀取不同的檔案  config.AddJsonFile($\u0026#34;Ocelot.{hostingContext.HostingEnvironment.EnvironmentName}.json\u0026#34;, true, true); }) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }) .ConfigureLogging((hostBuilderContext, loggingBuilder) =\u0026gt; { loggingBuilder.AddConfiguration(hostBuilderContext.Configuration.GetSection(\u0026#34;Logging\u0026#34;)); loggingBuilder.AddConsole(); loggingBuilder.AddDebug(); });  設定閘道路由  在這邊設定連近來與連出去的位置，還可以加上額外設定，FileCacheOptions(檔案快取)、RateLimitOptions(流量管控)等等\u0026hellip;\n{ \u0026#34;Routes\u0026#34;: [ //Catalog API  { \u0026#34;DownstreamPathTemplate\u0026#34;: \u0026#34;/api/v1/Catalog\u0026#34;,//要連接到的api路由  \u0026#34;DownstreamScheme\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;DownstreamHostAndPorts\u0026#34;: [//要連到的server位置  { \u0026#34;Host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;Port\u0026#34;: \u0026#34;8000\u0026#34; } ], \u0026#34;UpstreamPathTemplate\u0026#34;: \u0026#34;/Catalog\u0026#34;,//外面連到閘道的路由  \u0026#34;UpstreamHttpMethod\u0026#34;: [ \u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34; ],//允許的方法  \u0026#34;FileCacheOptions\u0026#34;: { \u0026#34;TtlSeconds\u0026#34;: 30 }//檔案快取選項:設定存活時間  }, { \u0026#34;DownstreamPathTemplate\u0026#34;: \u0026#34;/api/v1/Catalog/{id}\u0026#34;, \u0026#34;DownstreamScheme\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;DownstreamHostAndPorts\u0026#34;: [ { \u0026#34;Host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;Port\u0026#34;: \u0026#34;8000\u0026#34; } ], \u0026#34;UpstreamPathTemplate\u0026#34;: \u0026#34;/Catalog/{id}\u0026#34;, \u0026#34;UpstreamHttpMethod\u0026#34;: [ \u0026#34;GET\u0026#34;, \u0026#34;DELETE\u0026#34; ] }, //Basket API  { \u0026#34;DownstreamPathTemplate\u0026#34;: \u0026#34;/api/v1/Basket/Checkout\u0026#34;, \u0026#34;DownstreamScheme\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;DownstreamHostAndPorts\u0026#34;: [ { \u0026#34;Host\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;Port\u0026#34;: \u0026#34;8001\u0026#34; } ], \u0026#34;UpstreamPathTemplate\u0026#34;: \u0026#34;/Basket/Checkout\u0026#34;, \u0026#34;UpstreamHttpMethod\u0026#34;: [ \u0026#34;POST\u0026#34; ], \u0026#34;RateLimitOptions\u0026#34;: { //限制請求量3秒內只有第一筆會被接受  \u0026#34;ClientWhitelist\u0026#34;: [], \u0026#34;EnableRateLimiting\u0026#34;: true, \u0026#34;Period\u0026#34;: \u0026#34;3s\u0026#34;, \u0026#34;PeriodTimespan\u0026#34;: 1, \u0026#34;Limit\u0026#34;: 1 } ], \u0026#34;GlobalConfiguration\u0026#34;: { \u0026#34;BaseUrl\u0026#34;: \u0026#34;http://localhost:5010\u0026#34; } }  Gateway Aggregation 聚合模式  \r\n概念如圖所示，原本一個加入購物車的活動可能需要用到Catalog.API與Basket.API，需要經過閘道去多次呼叫特定API\n聚合模式下就是提供一個API，這個API會再去呼叫其他多個API\n 設定基礎服務 建立新專案後 在appsettings加入要連線的Url\n\u0026#34;ApiSettings\u0026#34;: { \u0026#34;CatalogUrl\u0026#34;: \u0026#34;http://localhost:8001\u0026#34;, \u0026#34;BasketUrl\u0026#34;: \u0026#34;http://localhost:8002\u0026#34;, \u0026#34;OrderingUrl\u0026#34;: \u0026#34;http://localhost:8003\u0026#34; } 在Startup設定HttpClient服務\npublic void ConfigureServices(IServiceCollection services) { services.AddHttpClient\u0026lt;ICatalogService, CatalogService\u0026gt;(c =\u0026gt; c.BaseAddress = new Uri(Configuration[\u0026#34;ApiSettings:CatalogUrl\u0026#34;])); services.AddHttpClient\u0026lt;IBasketService, BasketService\u0026gt;(c =\u0026gt; c.BaseAddress = new Uri(Configuration[\u0026#34;ApiSettings:BasketUrl\u0026#34;])); services.AddHttpClient\u0026lt;IOrderService, OrderService\u0026gt;(c =\u0026gt; c.BaseAddress = new Uri(Configuration[\u0026#34;ApiSettings:OrderingUrl\u0026#34;])); }  建立要呼叫後端API輸入或輸出的model public class OrderResponseModel { public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } }  建立後端Service public class OrderService : IOrderService { private readonly HttpClient _client; public OrderService(HttpClient client) { _client = client; } public async Task\u0026lt;IEnumerable\u0026lt;OrderResponseModel\u0026gt;\u0026gt; GetOrdersByUserName(string userName) { var response = await _client.GetAsync($\u0026#34;api/v1/Order/{userName}\u0026#34;); var dataAsString = await response.Content.ReadAsStringAsync().ConfigureAwait(false); return JsonSerializer.Deserialize\u0026lt;List\u0026lt;OrderResponseModel\u0026gt;\u0026gt;(dataAsString, new JsonSerializerOptions { PropertyNameCaseInsensitive = true }); } }  建立Controller controlooer被呼叫時，會去呼叫basketService、catalogService與orderService\n[HttpGet(\u0026#34;{userName}\u0026#34;, Name = \u0026#34;GetShopping\u0026#34;)] [ProducesResponseType(typeof(ShoppingModel), (int)HttpStatusCode.OK)] public async Task\u0026lt;ActionResult\u0026lt;ShoppingModel\u0026gt;\u0026gt; GetShopping(string userName) { var basket = await _basketService.GetBasket(userName); foreach (var item in basket.Items) { var product = await _catalogService.GetProductById(item.ProductId); item.ProductName = product.Name; item.Category = product.Category; item.Summary = product.Summary; item.Description = product.Description; item.ImageFile = product.ImageFile; } var orders = await _orderService.GetOrdersByUserName(userName); var shoppingModel = new ShoppingModel() { UserName = userName, BasketWithProduct = basket, Orders = orders }; return Ok(shoppingModel); }  最後在原本的ocelotGateway的josn檔裡面設定這個api的位置就好了\n","date":"2022-01-14T13:20:59+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20220114_apigateway%E7%AD%86%E8%A8%98.md/","title":"APIGateway筆記"},{"content":" 前置作業  RabbitMQ的兔兔icon怪可愛的，可以想像成郵局，可以收信也可以送信，是一堆兔兔幫你送信~🐰\n 安裝Docker 透過docker-compose來設定下載，alpine是輕量化體積較小的版本\n#docker-compose.ymlabbitmq:image:rabbitmq:3-management-alpine#docker-compose.override.ymlrabbitmq:container_name:rabbitmqrestart:alwaysports:- \u0026#34;5672:5672\u0026#34;- \u0026#34;15672:15672\u0026#34;#DashBoard的portdocker up上去後，測試看看能不能連線到localhost:15672，可以就會進到登入畫面，第一次直接登入帳密都是guest。\n MassTransit🚎 集體搭車去RabbitMQ的概念(?)，這是專給.Net用的套件，讓我們更簡單的去使用RabbitMQ的功能\n 建立Event製造機  建立EventBus.Messages項目專案\n安裝必要套件\n\u0026lt;PackageReference Include=\u0026#34;MassTransit\u0026#34; Version=\u0026#34;7.1.6\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;MassTransit.AspNetCore\u0026#34; Version=\u0026#34;7.1.6\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;MassTransit.RabbitMQ\u0026#34; Version=\u0026#34;7.1.6\u0026#34; /\u0026gt; 建立Base Event有ID與建構日期，讓其他Event去繼承它。\npublic class IntegrationBaseEvent { public IntegrationBaseEvent() { Id = Guid.NewGuid(); CreationDate = DateTime.UtcNow; } public IntegrationBaseEvent(Guid id, DateTime createDate) { Id = id; CreationDate = createDate; } public Guid Id { get; private set; } public DateTime CreationDate { get; private set; } } 建立結帳Event\npublic class BasketCheckoutEvent : IntegrationBaseEvent { public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } } 建立Common/EventBusConstants\n設定Queue的名子\npublic class EventBusConstants { public const string BasketCheckoutQueue = \u0026#34;basketcheckout-queue\u0026#34;; }  Event發送端  建立好EventBus.Messages後就可以開始來試著發送Event出去\n設定Dependencies添加EventBus.Messages\n安裝必要套件三件組後，在startup裡註冊MassTransit必要服務，並設定使用RabbitMq!\n\u0026lt;PackageReference Include=\u0026#34;MassTransit\u0026#34; Version=\u0026#34;7.1.6\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;MassTransit.AspNetCore\u0026#34; Version=\u0026#34;7.1.6\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;MassTransit.RabbitMQ\u0026#34; Version=\u0026#34;7.1.6\u0026#34; /\u0026gt;  註冊RabbitMQ服務 //可以看到AddMassTransit需要輸入Action type的參數，就是委託把不確定的動作，交由呼叫端來寫。 services.AddMassTransit(config =\u0026gt; { config.UsingRabbitMq((context, config) =\u0026gt; { //使用高級列隊協議amqp://帳號:密碼@網址:port (方便檢視，應該寫在appsettings)  config.Host(\u0026#34;amqp://guest:guest@localhost:5672\u0026#34;); }); }); services.AddMassTransitHostedService();  建立發送Event的API [Route(\u0026#34;[action]\u0026#34;)] [HttpPost] [ProducesResponseType((int)HttpStatusCode.Accepted)] [ProducesResponseType((int)HttpStatusCode.BadRequest)] public async Task\u0026lt;ActionResult\u0026gt; Checkout([FromBody] BasketCheckout basketCheckout)//雖然說可以直接用BasketCheckoutEvent類型，但是分開寫日後維護上比較輕鬆。 { //取得購物車內總金額  var basket = await _repository.GetBasket(basketCheckout.UserName); if(basket == null) { return BadRequest(); } //建立BasketCheckout Event  var eventMessage = _mapper.Map\u0026lt;BasketCheckoutEvent\u0026gt;(basketCheckout); //設定Event裡面的總金額  eventMessage.TotalPrice = basket.TotalPrice; //傳送Event給RabbitMQ  await _publishEndpoint.Publish(eventMessage); //清空購物車  await _repository.DeleteBasket(basket.UserName); return Accepted(); }  Event接收端  老樣子，安裝必備套件，註冊服務，但是註冊的地方有點不一樣，需要多做一些設定。\nservices.AddMassTransit(config =\u0026gt; { //設定Event處理器BasketCheckoutConsumer(下面會建)  config.AddConsumer\u0026lt;BasketCheckoutConsumer\u0026gt;(); config.UsingRabbitMq((busRegistrationContext, rabbitMqBusFactoryConfig) =\u0026gt; { //使用高級列隊協議amqp://帳號:密碼@網址:port  rabbitMqBusFactoryConfig.Host(Configuration[\u0026#34;EventBusSettings:HostAddress\u0026#34;]); //設定接收端點(Queue的名子, (端點設定)=\u0026gt;{設定Event處理器}  rabbitMqBusFactoryConfig.ReceiveEndpoint(EventBusConstants.BasketCheckoutQueue, endpointConfig =\u0026gt; { endpointConfig.ConfigureConsumer\u0026lt;BasketCheckoutConsumer\u0026gt;(busRegistrationContext); }); }); }); services.AddMassTransitHostedService(); //也別忘記註冊我們的Event處理器 services.AddScoped\u0026lt;BasketCheckoutConsumer\u0026gt;();  建立Event處理器 裡面的步驟很簡單，先把接收到RabbitMq裡面的Event Map成在Ordering.API可以用的格式，發送給mediator來處理，mediator會自動分類交由正確的的handler來處理接下來的邏輯，最後回傳結果。\n//實作介面IConsumer\u0026lt;要處理的Event\u0026gt;，要與publish過來的Event同class。 public class BasketCheckoutConsumer : IConsumer\u0026lt;BasketCheckoutEvent\u0026gt;// { private readonly IMediator _mediator; private readonly IMapper _mapper; private readonly ILogger\u0026lt;BasketCheckoutConsumer\u0026gt; _logger; public BasketCheckoutConsumer(IMediator mediator, IMapper mapper, ILogger\u0026lt;BasketCheckoutConsumer\u0026gt; logger) { _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator)); _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper)); _logger = logger ?? throw new ArgumentNullException(nameof(logger)); } public async Task Consume(ConsumeContext\u0026lt;BasketCheckoutEvent\u0026gt; context) { var command = _mapper.Map\u0026lt;CheckoutOrderCommand\u0026gt;(context.Message); var result = await _mediator.Send(command); _logger.LogInformation(\u0026#34;BasketCheckoutEvent Consume成功~~ Order Id : {newOrderId}\u0026#34;, result); } } 到這邊就可以在Basket.API產生Event，再透過rabbitmq傳送，最後Event交由Ording.API處理了\n 參考  實作官網教學\nRabbitMQ介紹\n","date":"2021-12-28T11:33:55+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211228_rabbitmq%E7%AD%86%E8%A8%98.md/","title":"RabbitMQ筆記"},{"content":" 建立Dockerfile  對專案項目按右鍵 \u0026raquo; Add \u0026raquo; Docker Support \u0026raquo; Linux \u0026raquo; 確定\n該項目下面就會有Dockerfile，裡面是建立容器的指令文字檔\n 建立Docker Compose  對專案項目按右鍵 \u0026raquo; Add \u0026raquo; Container Orchestrator Support(容器協調器支援) \u0026raquo; Docker Compose \u0026raquo; Linux \u0026raquo; 確定\n可以將多個container合而為一，也會多一個Docker Compose 項目\n#docker-compose.ymlservice:orderdb:#加入的serviceimage:mcr.microsoft.com/mssql/server:2019-latest#pull映像檔的位置#docker-compose.override.ymlservice:orderdb:container_name:orderdbenvironment:ACCEPT_EULA:\u0026#34;Y\u0026#34;SA_PASSWORD:\u0026#34;Max4129889\u0026#34;#system administrator密碼restart:alwaysports:- \u0026#34;1433:1433\u0026#34; 整合、執行映像檔  在終端機執行Docker-compose\ndocker-compose -f ./docker-compose.yml -f ./docker-compose.override.yml up -d 到這邊基本上就搞定了，查看一下容器有沒有好好運作~\n如果出現ERROR: yaml.parser.ParserError: while parsing a block mapping之類的錯誤\n很有可能是排版有誤，可以透過yml檢視器來進行查看\n出現docker.errors.DockerException: Error while fetching server API version: ('Connection aborted.', ConnectionRefusedError(61, 'Connection refused'))無法連線等問題\n需要先開啟Docker Desktop後再執行\ndocker ps  SQL GUI  在windows裡的Visual Studio可以使用Server Explorer直接連線DB進行查看\n在Mac下的Visual Studio貌似沒有這個功能，必須改用別的工具來進行查看\nDBreaver\n免費、好用、支持多種DB，推薦一下~😄\n 參考  https://hub.docker.com/_/microsoft-mssql-server\nhttps://docs.microsoft.com/zh-tw/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15\u0026pivots=cs1-bash\nyml檢視器\n","date":"2021-12-27T10:52:40+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211227_docker%E5%AE%B9%E5%99%A8%E5%8C%96_mssqlserver.md/","title":"Docker容器化"},{"content":" nslookup  紀錄一下今天學到的指令，想要查詢網站或是資料庫的ip位置，就可以使用nslookup來查詢，在windows、mac也都可以用。\nMacBook-Air ~ % nslookup www.google.com Server:\t172.20.10.1 Address:\t172.20.10.1#53 Non-authoritative answer: Name:\twww.google.com Address: 142.251.42.228 前面是DNS的位置\nNon-authoritative answer則是代表直接讀取DNS暫存，未認證的答案。\n","date":"2021-12-23T09:46:07+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211223_nslookup%E6%9F%A5%E8%A9%A2ip%E4%BD%8D%E7%BD%AE.md/","title":"nslookup查詢ip位置"},{"content":" 簡單介紹  在先前的簡潔架構Application Layer有寫通用的非同步Repository介面(Asynchronous Generic Repository)\n在這裡面有很多奇怪的東西😱\n先來看看通用的非同步Repository介面長什麼樣子\npublic interface IAsyncRepository\u0026lt;T\u0026gt; where T : EntityBase { Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAllAsync(); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, string includeString = null, bool disableTracking = true); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, List\u0026lt;Expression\u0026lt;Func\u0026lt;T, object\u0026gt;\u0026gt;\u0026gt; includes = null, bool disableTracking = true); Task\u0026lt;T\u0026gt; GetByIdAsync(int id); Task\u0026lt;T\u0026gt; AddAsync(T entity); Task UpdateAsync(T entity); Task DeleteAsync(T entity); } 在GetAsync()裡面有很多東西Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt;、Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt;、List\u0026lt;Expression\u0026lt;Func\u0026lt;T, object\u0026gt;\u0026gt;\u0026gt;\nFunc是Delegate類別，是一種可以reference method的類別，代表可以把方法當作參數丟進來。\nExpression是屬於Linq下的一個類別\nIQueryable\u0026lt;T\u0026gt;對特定已知的類型，查詢功能\nIOrderedQueryable\u0026lt;T\u0026gt;排序後的結果\n所以我們可以這樣呼叫\nIQueryable\u0026lt;T\u0026gt; query = _dbContext.Set\u0026lt;T\u0026gt;(); if (disableTracking) query = query.AsNoTracking(); if (!string.IsNullOrWhiteSpace(includeString)) query = query.Include(includeString); if (predicate != null) query = query.Where(predicate); if (orderBy != null) return await orderBy(query).ToListAsync(); return await query.ToListAsync(); }  參考  ","date":"2021-12-22T15:24:54+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211222_linqexpression.md/","title":"Linq Expression"},{"content":"基礎設施層，將我們Application Layer說的那些處理，連接到資料庫上。\n在這一層我們將使用Entity Framework Core AKA EF Core，EFCore的目的是讓程式設計師能夠以熟習的語言去操作資料庫，而非使用sql語法然後再轉成我們的資料模型。\n先去NuGet裝Microsoft.EntityFrameworkCore.SqlServer，使用.Net 5.0的話版本只支援到5.0.x以下，6.0.0不支援。\n Ordering.API  這跟infrastructure一樣，都是最外面一層，寫一起比較好整理吧\nController 得利於mediator的handler，我們整個controller就是一個清爽，基本上就是建立Request，丟給Handler來處理，最後把資料回傳就搞定了。\n[ApiController] [Route(\u0026#34;[controller]\u0026#34;)] public class OrderController : ControllerBase { private readonly IMediator _mediator; public OrderController(IMediator mediator) { _mediator = mediator; } [HttpGet(\u0026#34;{userName}\u0026#34;, Name = \u0026#34;GetOrder\u0026#34;)] [ProducesResponseType(typeof(IEnumerable\u0026lt;OrdersVm\u0026gt;), (int)HttpStatusCode.OK)] public async Task\u0026lt;ActionResult\u0026lt;IEnumerable\u0026lt;OrdersVm\u0026gt;\u0026gt;\u0026gt; GetOrdersByUserName(string userName) { //建立Request  var query = new GetOrdersListQuery(userName); //發送給Handler處理  List\u0026lt;OrdersVm\u0026gt; orders = await _mediator.Send(query); return Ok(orders); } [HttpPost(Name = \u0026#34;CheckoutOrder\u0026#34;)] [ProducesResponseType(StatusCodes.Status200OK)] public async Task\u0026lt;ActionResult\u0026lt;int\u0026gt;\u0026gt; CheckoutOrder([FromBody] CheckoutOrderCommand command) { var result = await _mediator.Send(command); return Ok(result); } [HttpPost(Name = \u0026#34;UpdateOrder\u0026#34;)] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesDefaultResponseType] public async Task\u0026lt;ActionResult\u0026gt; UpdateOrder([FromBody] UpdateOrderCommand command) { await _mediator.Send(command); return NoContent(); } [HttpPost(\u0026#34;{id}\u0026#34;, Name = \u0026#34;DeleteOrder\u0026#34;)] [ProducesResponseType(StatusCodes.Status200OK)] [ProducesResponseType(StatusCodes.Status404NotFound)] [ProducesDefaultResponseType] public async Task\u0026lt;ActionResult\u0026gt; DeleteOrder(int id) { var command = new DeleteOrderCommand() { Id = id }; await _mediator.Send(command); return NoContent(); } }  Persistence  我們在寫入資料庫前要紀錄新增、修改時間。\nOrderContext //繼承EFCore的DbContext框架類別 public class OrderContext : DbContext { public OrderContext(DbContextOptions options) : base(options) { } //Orders資料表  public DbSet\u0026lt;Order\u0026gt; Orders { get; set; } //我們可以override許多DbContext所提供的方法  //複寫SaveChangesAsync功能  public override Task\u0026lt;int\u0026gt; SaveChangesAsync(CancellationToken cancellationToken = default) { //在儲存變更前修改日期  foreach(var entry in ChangeTracker.Entries\u0026lt;EntityBase\u0026gt;()) { //判斷寫入的狀態(Added、Unchanged、Modified、Deleted)  switch (entry.State) { case EntityState.Added: entry.Entity.CreatedDate = DateTime.Now; entry.Entity.CreatedBy = \u0026#34;Max\u0026#34;; break; case EntityState.Modified: entry.Entity.LastModifiedDate = DateTime.Now; entry.Entity.LastModifiedBy = \u0026#34;Max\u0026#34;; break; } } return base.SaveChangesAsync(cancellationToken); } }  Repositories  RepositoryBase 操作資料庫的部分，將在Application layer的IAsyncRepository連起來。\npublic class RepositoryBase\u0026lt;T\u0026gt; : IAsyncRepository\u0026lt;T\u0026gt; where T : EntityBase { protected readonly OrderContext _dbContext; public RepositoryBase(OrderContext dbcontext) { _dbContext = dbcontext; } public async Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAllAsync() { return await _dbContext.Set\u0026lt;T\u0026gt;().ToListAsync(); } public async Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate) { return await _dbContext.Set\u0026lt;T\u0026gt;().Where(predicate).ToListAsync(); } public async Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, string includeString = null, bool disableTracking = true) { IQueryable\u0026lt;T\u0026gt; query = _dbContext.Set\u0026lt;T\u0026gt;(); if (disableTracking) query = query.AsNoTracking(); if (!string.IsNullOrWhiteSpace(includeString)) query = query.Include(includeString); if (predicate != null) query = query.Where(predicate); if (orderBy != null) return await orderBy(query).ToListAsync(); return await query.ToListAsync(); } public async Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, List\u0026lt;Expression\u0026lt;Func\u0026lt;T, object\u0026gt;\u0026gt;\u0026gt; includes = null, bool disableTracking = true) { IQueryable\u0026lt;T\u0026gt; query = _dbContext.Set\u0026lt;T\u0026gt;(); if (disableTracking) query = query.AsNoTracking(); if (includes != null) query = includes.Aggregate(query, (current, include) =\u0026gt; current.Include(include)); if (predicate != null) query = query.Where(predicate); if (orderBy != null) return await orderBy(query).ToListAsync(); return await query.ToListAsync(); } public virtual async Task\u0026lt;T\u0026gt; GetByIdAsync(int id) { return await _dbContext.Set\u0026lt;T\u0026gt;().FindAsync(id); } public async Task\u0026lt;T\u0026gt; AddAsync(T entity) { _dbContext.Set\u0026lt;T\u0026gt;().Add(entity); await _dbContext.SaveChangesAsync(); return entity; } public async Task UpdateAsync(T entity) { _dbContext.Entry(entity).State = EntityState.Modified; await _dbContext.SaveChangesAsync(); } public async Task DeleteAsync(T entity) { _dbContext.Set\u0026lt;T\u0026gt;().Remove(entity); await _dbContext.SaveChangesAsync(); } } 實作IOrderRepository\npublic class OrderRepository : RepositoryBase\u0026lt;Order\u0026gt;, IOrderRepository { //繼承RepositoryBase，也可以使用_dbContext  public OrderRepository(OrderContext dbConext) : base(dbConext) { } public async Task\u0026lt;IEnumerable\u0026lt;Order\u0026gt;\u0026gt; GetOrdersByUserName(string userName) { var orderList = await _dbContext.Orders.Where(o =\u0026gt; o.UserName == userName).ToListAsync(); return orderList; } }  Mail  Mail Service是使用SendGrid的API，簡單好用。\nNuGet裝SendGrid\n//繼承我們Application layer的IEmailService public class EmailService : IEmailService { public EmailSettings _emailSettings; public ILogger\u0026lt;EmailService\u0026gt; _logger; public EmailService(IOptions\u0026lt;EmailSettings\u0026gt; emailSettings, ILogger\u0026lt;EmailService\u0026gt; logger) { _emailSettings = emailSettings.Value; _logger = logger; } public async Task\u0026lt;bool\u0026gt; SendEmail(Email email) { var client = new SendGridClient(_emailSettings.ApiKey);//使用SendGrid發送email的服務  var from = new EmailAddress(_emailSettings.FromAddress, _emailSettings.FromName);//寄件人  var subject = email.Subject;//主旨  var to = new EmailAddress(email.To);//收件人  //email本體  var emailBody = email.Body; var htmlContent = \u0026#34;\u0026lt;strong\u0026gt;and easy to do anywhere, even with C#\u0026lt;/strong\u0026gt;\u0026#34;; var msg = MailHelper.CreateSingleEmail(from, to, subject, emailBody, htmlContent);//建立信件  var response = await client.SendEmailAsync(msg);//發送信件  if(response.StatusCode == System.Net.HttpStatusCode.Accepted || response.StatusCode == System.Net.HttpStatusCode.OK) { _logger.LogInformation(\u0026#34;Email發送成功\u0026#34;); return true; } _logger.LogError(\u0026#34;Email發送失敗\u0026#34;); return false; } }  DI Service Collection  打包要註冊的服務\npublic static class InfrastructureServiceRegistration { public static IServiceCollection AddInfrastructureService(this IServiceCollection services, IConfiguration configuration) { //ConnectionString來自於Ordering.API的appsettings.json  services.AddDbContext\u0026lt;OrderContext\u0026gt;(options =\u0026gt; options.UseSqlServer(configuration.GetConnectionString(\u0026#34;OrderingConnectionString\u0026#34;))); services.AddScoped(typeof(IAsyncRepository\u0026lt;\u0026gt;), typeof(RepositoryBase\u0026lt;\u0026gt;)); services.AddScoped\u0026lt;IOrderRepository, OrderRepository\u0026gt;(); services.Configure\u0026lt;EmailSettings\u0026gt;(c =\u0026gt; configuration.GetSection(\u0026#34;EmailSettings\u0026#34;)); services.AddTransient\u0026lt;IEmailService, EmailService\u0026gt;(); return services; } } 一次在Order.API的Startup.cs內註冊Application與Infrastructure的服務\n// This method gets called by the runtime. Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { services.AddApplicationServices(); services.AddInfrastructureServices(Configuration); services.AddControllers(); services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;Ordering.API\u0026#34;, Version = \u0026#34;v1\u0026#34; }); }); }  生成Migration檔案  遷移資料庫可以想像成資料庫的版本控制，記錄我們用成對資料庫的資料結構做的變更，保持 EF Core 模型與資料庫結構描述同步，EF Core 模型成為真實來源，請使用移轉。 當變更 EF Core 模型時，這種方式會以遞增方式將對應的結構描述變更套用至資料庫。\n先在Order.API裝Microsoft.EntityFrameworkCore.Tools，我們希望生成的檔案在Infrastructure內，所以接著在Package Manage Console裡把預設專案切換到Order.Infrastructure後，輸入Add-Migration InitialCreate。\n以上是依照課程步驟，這在windows下也許可行，但很遺憾我的在Mac上跑，一直出現錯誤😠。\nUnable to create an object of type 'OrderContext'. For the different patterns supported at design time, see https://go.microsoft.com/fwlink/?linkid=851728\n最後找了很久，在Mac上要生成Migration檔案的步驟如下\ncd 到DbContext的那一個項目資料夾下，這邊是Ordering.Infrastructure/\n接著執行dotnet restore\ndotnet ef --startup-project ../Ordering.Api/ migrations add InitialCreate --verbose --startup-project 設定啟動專案\nmigrations add 生成Migration檔案\n--verbose 輸出log，方便查詢錯誤\n參考: https://stackoverflow.com/questions/55123853/unable-to-create-an-object-of-type-dbcontexts-name-for-the-different-patte\n最後會生成一個Migration資料夾，裡面包含紀錄版本的程式碼、紀錄資料模型如何對應到資料庫的，最後是Model快照。\n更多操作或說明: https://ithelp.ithome.com.tw/articles/10240606\n 遷移資料庫  我們在Order.API的Program裡，在host執行前進行資料庫遷移的動作，並把seeder的方法當作參數傳送進去。\npublic class Program { public static void Main(string[] args) { var host = CreateHostBuilder(args).Build(); //把方法當作參數傳送過去  host.MigrateDatabase\u0026lt;OrderContext\u0026gt;((context, services)=\u0026gt; { //記得加上using Microsoft.Extensions.DependencyInjection;  //這樣才可以使用GetService的方法  var logger = services.GetService\u0026lt;ILogger\u0026lt;OrderContextSeed\u0026gt;\u0026gt;(); OrderContextSeed.SeedAsync(context, logger).Wait(); }); host.Run(); } } 這邊會進行資料庫遷移的動作，若發生錯誤則會重新執行。\npublic static class HostExtensions { //Action\u0026lt;A,B\u0026gt;代表兩個輸入不回傳的封裝函數，就像(A,B)=\u0026gt;{ ... }方法  public static IHost MigrateDatabase\u0026lt;TContext\u0026gt;(this IHost host, Action\u0026lt;TContext, IServiceProvider\u0026gt; seeder, int? retry = 10) where TContext : DbContext { using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; var logger = services.GetRequiredService\u0026lt;ILogger\u0026lt;TContext\u0026gt;\u0026gt;(); var context = services.GetService\u0026lt;TContext\u0026gt;();//取得OrderContext的地方  try { logger.LogInformation($\u0026#34;開始遷移資料庫成{typeof(TContext).Name}的形狀\u0026#34;); context.Database.Migrate();//執行遷移  seeder(context, services);//執行seeder，傳送進來的方法。  logger.LogInformation($\u0026#34;遷移資料庫成{typeof(TContext).Name}的形狀結束\u0026#34;); } catch (Exception err) { logger.LogError(err, \u0026#34;寫入資料庫時發生錯誤\u0026#34;); if (retry \u0026gt; 0) { retry--; System.Threading.Thread.Sleep(2000); MigrateDatabase\u0026lt;TContext\u0026gt;(host, seeder, retry); } } } return host; } } 之所以要這樣寫的原因是MigrateDataBase\u0026lt;TContext\u0026gt;是透過泛型來處理，\n直到var context = services.GetService\u0026lt;TContext\u0026gt;();才取得OrderContext的地方\n寫在裡面並沒有辦法確定TContext的類型，寫在外面的話就可以確定\n因為host.MigrateDatabase\u0026lt;OrderContext\u0026gt;在這邊就確定型別的同時，也確定seeder的第一個參數了\n 連接資料庫與Docker容器化  DB是使用Microsoft SQL Server的映像檔 詳細的操作可以參考這篇Docker容器化_MSSQLServer\n架設好資料庫後，在appsettings裡加上連接字串，Server位置為localhost預設port為1433，帳密為sa/Max4129889\n\u0026#34;ConnectionStrings\u0026#34;: { \u0026#34;OrderingConnectionString\u0026#34;: \u0026#34;Server=localhost;Database=OrderDb;User Id=sa;Password=Max4129889;\u0026#34; } 到這邊基本上就可以測試一下我們的Ordering.API，沒問題後接著也把Ordering.API容器化，跟這篇Docker容器化_MSSQLServer裡面的操作一樣，Dockerfile、Docker-compose.yml也都會自動設定好，我們只要在Docker-compose.override.yml裡做一些設定即可。\n這邊的連結字串改成一行冒號、雙引號要做調整，最重要的是Server=orderdb，改指向orderdb(MSSQL的微服務)。\nordering.api:container_name:ordering.apienvironment:- ASPNETCORE_ENVIRONMENT=Development- \u0026#34;ConnectionStrings__OrderingConnectionString=Server=orderdb;Database=OrderDb;User Id=sa;Password=Max4129889;\u0026#34;depends_on:- orderdbports:- \u0026#34;8004:80\u0026#34;最後執行docker-compose指令，搞定收工。\n 參考  Docker容器化_MSSQLServer\n簡潔架構 Application Layer\n簡潔架構 Infrastructure Layer\nhttps://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/\n","date":"2021-12-22T13:32:25+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211222_%E7%B0%A1%E6%BD%94%E6%9E%B6%E6%A7%8Binfrastructure.md/","title":"簡潔架構 Infrastructure Layer"},{"content":" 憑證  主要的功能是確認公鑰擁有者的身份，避免我們拿到冒用者的公鑰。\n要怎麼確定呢？找大家都信任的公正的第三方來，就是數位憑證認證機構(Certificate Authority，CA)。\n要取得憑證，應先向CA提出申請，CA判明申請者的身分後，為之分配一個公鑰，並將該公鑰與其身分資訊繫結，為該整體簽名，簽名後的整體即為憑證，發還給申請者。\n在公司用的通常是萬用憑證，連同子網域都可以用的憑證*.google.com，blog.google.com、mail.google.com等，都可以直接使用相同的憑證。\n 溝通流程  用戶 - - - - - - HTTPS 伺服器您好，我支援TLS XX版本 - - - - - \u0026raquo; 伺服器\n用戶 \u0026laquo; - - - - - - - Hi 這是我的憑證 - - - - - - - - - - - - 伺服器\n用戶 確認憑證沒有問題\u0026hellip;(用CA的公鑰對那個憑證上的簽字進行驗證)\n確認不是中間人後，就可以進行金鑰交換的步驟了，並經過各種演算法讓你可以直接傳資料，且不用擔心被竊聽。\n 參考  https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84\nhttps://www.youtube.com/watch?v=63tKc67T2jM\nhttps://medium.com/@clu1022/%E9%82%A3%E4%BA%9B%E9%97%9C%E6%96%BCssl-tls%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B-%E4%B9%9D-ssl-communication-31a2a8a888a6\n","date":"2021-12-21T13:22:15+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211221_%E6%8F%9B%E6%86%91%E8%AD%89.md/","title":"換憑證"},{"content":" 購買原因  加入了XBOX Game Pass後，遊戲玩不完，空間不夠放了啊，原先地平線5是放在傳統硬碟裡，開車開到一半，路直接不見，進入遊戲也要等個3分鐘，速度實在太慢了。\n沒什麼時間做功課，趕在雙12結束前下單優惠比較多，原本想要透過pchome+Line導購，一沒注意時間錯過了導購回饋的時間，改去蝦皮原價屋買，回饋少了一點，但也還行吧，2244$，沒時間解釋了，快上車。\n由於我的主機板x470i剩主板後面一個m.2插槽可以用，背面沒有散熱片可以用，itx機殼又容易積熱，所以主要訴求是希望硬碟溫度能夠低，發熱量小點。\n\r藍藍的看起來很清涼🥶\r\n順帶一提，過去擁有不少顆傳統硬碟(大概8、9顆)，只壞過WD牌的，個人覺得最耐操的是HGST(在被WD買下前)，可惜現在都買不到了，現在這顆我也還在服役，就是速度慢了些。再給吃過HGST口水的WD一個機會。\n 移動遊戲到新硬碟裡  設定 \u0026raquo; 應用程式 \u0026raquo; 找到遊戲 \u0026raquo; 移動\n就可以直接移動到新的硬碟去了，還好不用重新下載幾百G的檔案。\n 曬一下電腦照  \ritx就是桌面吸塵器\r\n這台電腦自從裝好後就再也沒拆過了，這組裝實在太麻煩了XD，有夠難裝，線也是我自己弄的，組完還蠻有成就感的。兩年前組好(顯卡二手+線材+沿用舊傳統硬碟)總花費大概為30000出頭，是非常貴的一格價格，我把實習賺的錢全部都砸在這台電腦上，要組itx很多東西都是要買特定規格的，能省錢的地方不多，而且電腦通常一組就好幾年，可以買價格合理，品質耐用的產品。\n CPU AMD Ryzen™ 5 3600 主機板 ROG STRIX X470-I GAMING 記憶體 Micron Ballistix Sport LT 3200 8G *2 顯示卡 ROG-STRIX-GTX1060-O6G-GAMING 電源 CORSAIR SF450 80Plus SSD PLEXTOR M9PeGn 1TB M.2 2280 PCIe SSD SSD WD Blue™ SN550 NVMe™ 硬碟 HGST 7200RPM 750GB 硬碟 TOSHIBA 5200RPM 500GB 機殼 K01 6.5L A4 散熱器 CRYORIG C7   後記  平常待機溫度大概40℃左右，遊戲中的溫度在55℃就沒有再上去了，可能啟動什麼保護機制之類的吧，後面的散熱還是太差了，CPU、GPU兩頭燒。\n","date":"2021-12-21T09:41:12+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211220_sn550%E9%96%8B%E7%AE%B1.md/","title":"WD Blue™ SN550 小開箱"},{"content":" 取得磁碟狀態  工作上總是一堆鳥事，在甲方裡工作有時候又要處理一些完全沒有意義的雜事，浪費時間。\n總之因為不明原因，我需要每週紀錄主機的磁碟剩餘容量百分比\u0026hellip;\n要取得磁碟訊息很簡單，使用System.IO的DriveInfo.GetDrives()可以取得所有磁碟，再把DriveInfo的屬性取出來\nstring diskStatus = \u0026#34;\u0026#34;; DriveInfo[] allDrives = DriveInfo.GetDrives(); foreach (DriveInfo d in allDrives) { if (d.IsReady == true)//確定磁碟就緒  { int freePercent = (int)(d.TotalFreeSpace / (float)d.TotalSize * 100); diskStatus += $\u0026#34; {d.Name}{freePercent} \u0026#34; } }  寫入紀錄(過時，改由Mail發送)  這邊一切以簡單為主，直接用寫入文字檔的方式來進行\n//如果有額外輸入檔案路徑的話，就把第一個參數當作路徑，沒有就丟在桌面 //若不想在排程器那裡設定開始位置的話，就用絕對路徑吧。 string path = args.Length == 1 ? args[0] : \u0026#34;DiskLog.txt\u0026#34;; //記錄時間 string now = DateRime.Now.ToString(\u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;); using StreamWriter file = new (path, append: true); file.WriteLine($\u0026#34;{now}\u0026gt;\u0026gt; {diskStatus}\u0026#34;);  新增排程  這邊基本就點點滑鼠就搞定了\n電腦管理 \u0026raquo; 工作排程器 \u0026raquo; 建立工作\n輸入名稱\n觸發程序 \u0026raquo; 新增 \u0026raquo; 每週\n動作 \u0026raquo; 新增 \u0026raquo; 程式或指令碼(選擇我們程式的exe檔) \u0026raquo; 新增引數(輸入檔案路徑) \u0026raquo; 開始位置(預設為C:\\WINDOWS\\System32)\n 加上錯誤處理  沒什麼意外是不會錯啦，但總是有意外XD，加個try..catch處理就好，最後大概如下。\ntry { string diskStatus = \u0026#34;\u0026#34;; DriveInfo[] allDrives = DriveInfo.GetDrives(); foreach (DriveInfo d in allDrives) { if (d.IsReady == true)//確定磁碟就緒  { int freePercent = (int)(d.TotalFreeSpace / (float)d.TotalSize * 100); diskStatus += $\u0026#34; {d.Name}{freePercent} \u0026#34; } } //如果有額外輸入檔案路徑的話，就把第一個參數當作路徑，沒有就丟在桌面  //若不想在排程器那裡設定開始位置的話，就用絕對路徑吧。  string path = args.Length == 1 ? args[0] : \u0026#34;DiskLog.txt\u0026#34;; //記錄時間  string now = DateRime.Now.ToString(\u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;); using StreamWriter file = new (path, append: true); file.WriteLine($\u0026#34;{now}\u0026gt;\u0026gt; {diskStatus}\u0026#34;); } catch(Exception ex) { Console.WriteLine(ex); Console.ReadKey();//卡個畫面 }  取得IP與發送Email服務(更新)  取得本機IP位置\nstring ip = Dns.GetHostEntry(Dns.GetHostName()).AddressList .Where(q =\u0026gt; q.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) .FirstOrDefault().ToString(); 發送Mail\nprivate static void SendMail(string now, string ip, string diskStatus) { MailMessage mailMsg = new MailMessage(); mailMsg.Subject = $\u0026#34;{ip} \u0026gt;\u0026gt; {dickStatus}\u0026#34;; //主旨  mailMsg.To.Add(new MailAddress(\u0026#34;xxx@gmail.com\u0026#34;));//收件人地址  mailMsg.From = new MailAddress(\u0026#34;ooo@gmail.com\u0026#34;, \u0026#34;主機紀錄機器人\u0026#34;);//寄件人地址  mailMsg.Body = $\u0026#34;{ip} \u0026gt;\u0026gt; {dickStatus}\u0026#34;; //內文  //設定mail server  SmtpClient client = new SmtpClient(); client.Credentials = new System.Net.NetworkCredential(\u0026#34;XXX@gmail.com\u0026#34;, \u0026#34;****\u0026#34;); //這裡要填正確的帳號跟密碼  client.Host = \u0026#34;smtp.gmail.com\u0026#34;; //設定smtp Server  client.Port = 25; //設定Port  client.EnableSsl = true; //gmail預設開啟驗證  client.Send(mailMsg); //寄出信件  client.Dispose(); }  參考  https://docs.microsoft.com/zh-tw/dotnet/api/system.io.driveinfo.getdrives?view=net-6.0\nhttps://ithelp.ithome.com.tw/articles/10190120\n","date":"2021-12-17T17:09:56+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211217_windows%E6%8E%92%E7%A8%8B%E7%B4%80%E9%8C%84%E4%B8%BB%E6%A9%9F%E7%A3%81%E7%A2%9F%E7%8B%80%E6%85%8B.md/","title":"windows排程紀錄主機磁碟狀態"},{"content":" Application Layer  注重於商業需求而不是實作一些外部系統的東西，DB之類的。\n在這一層裡有三個主要的資料夾Contracts、Features、Behaviors，分別為存放服務介面、Use case、驗證用戶行為。\n主要在於Fetures，根據DDD並使用MediatR為每一個需求做獨自的CQRS操作，\n Contracts  存放各Services的interface的地方\nPersistence 通用的非同步Repository介面(Asynchronous Generic Repository)\n裡面包含常用的功能。\n//泛型T必需繼承Domina Layer的EntityBase(Id、createdBy、createDate、LastModifiedDate等等的東西) public interface IAsyncRepository\u0026lt;T\u0026gt; where T : EntityBase { Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAllAsync(); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, string includeString = null, bool disableTracking = true); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, List\u0026lt;Expression\u0026lt;Func\u0026lt;T, object\u0026gt;\u0026gt;\u0026gt; includes = null, bool disableTracking = true); Task\u0026lt;T\u0026gt; GetByIdAsync(int id); Task\u0026lt;T\u0026gt; AddAsync(T entity); Task UpdateAsync(T entity); Task DeleteAsync(T entity); } 下訂單Repository介面，在這邊我們可以建立自己的方法、功能，後面處理Request時會用到。\npublic interface IOrderRepository : IAsyncRepository\u0026lt;Order\u0026gt;//Order來自Domian Layer的Entity { Task\u0026lt;IEnumerable\u0026lt;Order\u0026gt;\u0026gt; GetOrdersByUserName(string userName); } Infrastructure Email發送服務介面，Email class建立在Models/Email.cs\npublic interface IEmailService { Task\u0026lt;bool\u0026gt; SendEmail(Email email); }  Features  存放Use case，目前只有Orders一個Use case，並實作CQRS。\n建資料夾 Features/Orders/Commands Features/Orders/Queries\nQueries只有一個方法，GetOrderList。\nCommands裡面有三個方法，CheckOrder、UpdateOrder、DeleteOrder。\nQueries/GetOrderList 先處理Queries\nFeatures/Orders/Queries/GetOrdersList/GetOrdersListQuery.cs Features/Orders/Queries/GetOrdersList/GetOrdersListQueryHandler.cs Features/Orders/Queries/GetOrdersList/OrdersVm.cs\nGetOrdersListQuery IRequest介面來自於MediatR DI Version，裡面List\u0026lt;OrdersVm\u0026gt;代表要回傳的type\nusing MediatR; public class GetOrdersListQuery : IRequest\u0026lt;List\u0026lt;OrdersVm\u0026gt;\u0026gt; { public string UserName { get; set; } public GetOrdersListQuery(string userName) { UserName = userName ?? throw new ArgumentNullException(nameof(userName)); } } GetOrdersListQueryHandler 當Query被觸發時Handler會負責處理，實作IRequestHandler會得到Handle這個Function，並寫入我們要進行的操作\n//IRequestHandler\u0026lt;要處理的IRequest, 輸出的type\u0026gt; public class GetOrdersListQueryHandler : IRequestHandler\u0026lt;GetOrdersListQuery, List\u0026lt;OrdersVm\u0026gt;\u0026gt; { private readonly IOrderRepository _orderRepository; private readonly IMapper _mapper; //使用在Contract裡面寫的orderRepository  public GetOrdersListQueryHandler(IOrderRepository orderRepository, IMapper mapper) { _orderRepository = orderRepository; _mapper = mapper; } public async Task\u0026lt;List\u0026lt;OrdersVm\u0026gt;\u0026gt; Handle(GetOrdersListQuery request, CancellationToken cancellationToken) { var orderList = await _orderRepository.GetOrdersByUserName(request.UserName); return _mapper.Map\u0026lt;List\u0026lt;OrdersVm\u0026gt;\u0026gt;(orderList); } } OrdersVm 可以看到這個class是放在Queries/GetOrdersList裡面，只給GetOrdersList這個Use Case用，與Entity層的Order.cs無關，雖然他們長得一樣。\npublic class OrdersVm { public int Id { get; set; } public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } } Commands/CheckoutOrder 接下來要處理Command的部分\n先處理CheckoutOrder\n//Features/Orders/Commands/CheckoutOrder/CheckoutOrderCommand.cs //回傳int訂單編號 public class CheckoutOrderCommand : IRequest\u0026lt;int\u0026gt; { public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } } 一樣使用MediatR的功能，透過handler來處理\n//Features/Orders/Commands/CheckoutOrder/CheckoutOrderCommandHandler.cs public class CheckoutOrderCommandHandler : IRequestHandler\u0026lt;CheckoutOrderCommand, int\u0026gt; { private readonly IOrderRepository _orderRepository; private readonly IMapper _mapper; //Application層下的mappings  private readonly IEmailService _emailService;//Application層下的contracts/infastucture  private readonly ILogger\u0026lt;CheckoutOrderCommandHandler\u0026gt; _logger; //依賴注入需要的元件  public CheckoutOrderCommandHandler(IOrderRepository orderRepository, IMapper mapper, IEmailService emailService, ILogger\u0026lt;CheckoutOrderCommandHandler\u0026gt; logger) { _orderRepository = orderRepository ?? throw new ArgumentNullException(nameof(orderRepository)); _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper)); _emailService = emailService ?? throw new ArgumentNullException(nameof(emailService)); _logger = logger ?? throw new ArgumentNullException(nameof(logger)); } //實作IRequestHandler  public async Task\u0026lt;int\u0026gt; Handle(CheckoutOrderCommand request, CancellationToken cancellationToken) { var orderEntity = _mapper.Map\u0026lt;Order\u0026gt;(request); var newOrder = await _orderRepository.AddAsync(orderEntity); _logger.LogInformation($\u0026#34;訂單{newOrder.Id}建立成功\u0026#34;); await SendMail(newOrder); return newOrder.Id; } private async Task SendMail(Order order) { var email = new Email() { To = \u0026#34;test@gmail.com\u0026#34;, Body = $\u0026#34;Order was created.\u0026#34;, Subject = \u0026#34;Order was created\u0026#34; }; try { await _emailService.SendEmail(email); } catch (Exception ex) { _logger.LogError($\u0026#34;訂單{order.Id}發生錯誤，mail service: {ex.Message}\u0026#34;); } } } 最後會加上一個驗證，在Behaviors那邊加入。\nusing FluentValidation;//使用驗證套件 public class CheckoutOrderCommandValidator : AbstractValidator\u0026lt;CheckoutOrderCommand\u0026gt; { public CheckoutOrderCommandValidator() { //p代表property  RuleFor(p =\u0026gt; p.UserName)//驗證UserName  .NotEmpty().WithMessage(\u0026#34;UserName 必填\u0026#34;)//不可為空值，若為空值回傳訊息  .NotNull() .MaximumLength(50).WithMessage(\u0026#34;UserName 字數過長\u0026#34;); RuleFor(p =\u0026gt; p.EmailAddress) .NotEmpty().WithMessage(\u0026#34;EmailAddress 必填\u0026#34;); RuleFor(p =\u0026gt; p.TotalPrice) .NotEmpty().WithMessage(\u0026#34;TotalPrice 必填\u0026#34;) .GreaterThan(0).WithMessage(\u0026#34;TotalPrice 需要大於0\u0026#34;); } } Commands/DeleteOrder UpdateOrder、DeleteOrder基本與CheckoutOrder類似，不過有幾個地方不太一樣。\nCommand只需要IRequest，不需用泛型。\npublic class DeleteOrderCommand : IRequest { public int Id { get; set; } } 如果Command本身沒有要回傳值的話，就回傳Unit.Value給MediatR知道\npublic async Task\u0026lt;Unit\u0026gt; Handle(DeleteOrderCommand request, CancellationToken cancellationToken) { var orderToDelete = await _orderRepository.GetByIdAsync(request.Id); if(orderToDelete == null) { throw new Exception($\u0026#34;找不到訂單{request.Id}\u0026#34;); } await _orderRepository.DeleteAsync(orderToDelete); _logger.LogInformation($\u0026#34;訂單{request.Id}刪除完成\u0026#34;); return Unit.Value;//如果Command本身沒有要回傳值的話，就回傳Unit.Value給MediatR知道 }  Behaviors  我們會在Handler前後進行驗證User使用的行為(輸入)是否正常\n整個流程大概如下\nCaller \u0026raquo; Request \u0026raquo; 前處理 \u0026raquo; Handler \u0026raquo; 後處理\n//實作MediatR提供的IPipelineBehavior來註冊前、後處理 public class ValidationBehaviour\u0026lt;TRequest, TResponse\u0026gt; : IPipelineBehavior\u0026lt;TRequest, TResponse\u0026gt; { //這將會讀取所有Validator，只要有繼承AbstractValidator\u0026lt;TRequest\u0026gt;(來自FluentValidation)  private readonly IEnumerable\u0026lt;IValidator\u0026lt;TRequest\u0026gt;\u0026gt; _validators; public ValidationBehaviour(IEnumerable\u0026lt;IValidator\u0026lt;TRequest\u0026gt;\u0026gt; validators) { _validators = validators; } public async Task\u0026lt;TResponse\u0026gt; Handle(TRequest request, CancellationToken cancellationToken, RequestHandlerDelegate\u0026lt;TResponse\u0026gt; next) { if (_validators.Any())//如果有Validator的話  { //驗證輸入  var context = new ValidationContext\u0026lt;TRequest\u0026gt;(request); //等待所有非同步執行結果 ( 對所有驗證項目進行非同步工作 )  var validationResults = await Task.WhenAll(_validators.Select(v =\u0026gt; v.ValidateAsync(context, cancellationToken))); //查看結果  var failures = validationResults.SelectMany(r =\u0026gt; r.Errors).Where(f =\u0026gt; f != null).ToList(); //如果有錯的話  if (failures.Count != 0) { throw new ValidationException(failures); } } //前處理的部份到此結束  var response = await next();//Handler處理完回傳  //後處理的部分從此開始  //....  //後處理結束  return response;//回傳回應結果  } }  DI Service Collection  因為使用的服務有點多，把他們集中管理成一個Service Collection，之後直接註冊這個Collection就好了。\npublic static class ApplicationServiceRegistration { public static IServiceCollection AddApplicationServices(this IServiceCollection services) { services.AddAutoMapper(Assembly.GetExecutingAssembly()); services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly()); services.AddMediatR(Assembly.GetExecutingAssembly()); services.AddTransient(typeof(IPipelineBehavior\u0026lt;,\u0026gt;), typeof(UnhandledExceptionBehaviour\u0026lt;,\u0026gt;)); services.AddTransient(typeof(IPipelineBehavior\u0026lt;,\u0026gt;), typeof(ValidationBehaviour\u0026lt;,\u0026gt;)); return services; } } 到這邊Application Layer就到一段落了，實在很多很長，主要實作了CQRS與學習MediatR的操作，也更看清楚整個簡潔架構的設計。\n 參考  簡潔架構 Application Layer\n簡潔架構 Infrastructure Layer\nhttps://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/\n","date":"2021-12-17T11:44:52+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211217_%E7%B0%A1%E6%BD%94%E6%9E%B6%E6%A7%8Bapplication.md/","title":"簡潔架構 Application Layer"},{"content":" 筆記  雖說在工作上能不用第三方套件就不用，但練習的時候想做什麼就做什麼吧，一切輕鬆、簡單最好了。可以考慮用看看。\n紀錄一下常用的功能，範例取自訂單結帳前處理的部分。\nusing FluentValidation;//使用套件 public class CheckoutOrderCommandValidator : AbstractValidator\u0026lt;CheckoutOrderCommand\u0026gt;//要驗證的class { public CheckoutOrderCommandValidator() { //p代表property  RuleFor(p =\u0026gt; p.UserName)//驗證UserName  .NotEmpty().WithMessage(\u0026#34;UserName 必填\u0026#34;)//不可為空值，若為空值回傳訊息  .NotNull() .MaximumLength(50).WithMessage(\u0026#34;UserName 字數過長\u0026#34;); RuleFor(p =\u0026gt; p.EmailAddress) .NotEmpty().WithMessage(\u0026#34;EmailAddress 必填\u0026#34;); RuleFor(p =\u0026gt; p.TotalPrice) .NotEmpty().WithMessage(\u0026#34;TotalPrice 必填\u0026#34;) .GreaterThan(0).WithMessage(\u0026#34;TotalPrice 需要大於0\u0026#34;); } } 取得各個Validator\n//這將會讀取所有Validator，只要有繼承AbstractValidator\u0026lt;TRequest\u0026gt;(來自FluentValidation) private readonly IEnumerable\u0026lt;IValidator\u0026lt;TRequest\u0026gt;\u0026gt; _validators; public ValidationBehaviour(IEnumerable\u0026lt;IValidator\u0026lt;TRequest\u0026gt;\u0026gt; validators) { _validators = validators; } 使用Validator\nif (_validators.Any())//如果有Validator的話 { //驗證輸入  var context = new ValidationContext\u0026lt;TRequest\u0026gt;(request); //等待所有非同步執行結果 ( 對所有驗證項目進行非同步工作 )  var validationResults = await Task.WhenAll(_validators.Select(v =\u0026gt; v.ValidateAsync(context, cancellationToken))); //查看結果  var failures = validationResults.SelectMany(r =\u0026gt; r.Errors).Where(f =\u0026gt; f != null).ToList(); //如果有錯的話  if (failures.Count != 0) { throw new ValidationException(failures); } } ","date":"2021-12-16T14:50:26+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211216_fluentvalidation%E9%A9%97%E8%AD%89%E5%A5%97%E4%BB%B6.md/","title":"FluentValidation"},{"content":" 案發原因  不知道有多久沒有更新我的Line了，也沒有什麼值得我更新的功能，這樣穩穩著用就挺好的，早上收到Line錢包提醒我必須在12/31號前更新到最新版，平常出門已經很習慣Pay來Pay去了，得很方便，所以只能更新了。\nBOOM!\n更新完後Line直接閃退，再也打不開了，卸載重裝、重新開機都試過了，更新iOS到最新版本還是打不開，只好寫email給客服來處理，來回處理了兩天左右，客服發送消息給我說他們修正了問題，請至App Store更新最新版，這次更新完後終於可以登入了，還是要給他們的工程師點讚，這個效率算很快了。\nBOOM!ANGIN!\n原以為事情到這裡就告一個段落了，沒想到更新後導致的問題一一浮現，平常在使用的iPad 3居然連不到我手機的熱點了，一查才發現iOS 15加強了wifi存取保護(Wi-Fi Protected Access)，從wpa2升級到wpa3，導致不支援wpa3的設備將無法連接，而我的iPad 3就這樣再也連不上網路了。更慘的是網路上查了一輪，還是沒找到解決方法。\n只能祈求之後會開放可以改wpa2的選項，雖然我覺得很難。._.\n","date":"2021-12-16T13:10:12+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211216_%E6%9B%B4%E6%96%B0%E5%BE%9E%E4%BE%86%E5%B0%B1%E6%B2%92%E6%9C%89%E5%A5%BD%E4%BA%8B.md/","title":"更新從來就沒有好事情"},{"content":" 筆記  工作上剛好遇到一個需求，要過濾用戶輸入的英文ID\n 判斷規則\n 格式限定半形大寫英文 符號只能輸入.、-、/、\\還有空白 長度最長為50字元 至少有三個英文字，不可只有符號   原本打算先判斷輸入的正確的英文與符號且長度為3~50，在判斷英文字至少三個。\nusing System.Text.RegularExpressions; string EnglishName = \u0026#34;TEST-123\u0026#34;//user input Regex.IsMatch(EnglishName, \u0026#34;@^[A-Z//.\\\\\\s]{3,50}$\u0026#34;); Regex.IsMatch(EnglishName, \u0026#34;@^[A-Z{3,}$\u0026#34;); 使用預查來處理這個問題\n  正向肯定預查 (?=pattern) 表示從當前位置開始，預測後面的文字必須匹配上pattern 正向否定預查 (?!pattern) 表示從當前位置開始，預測後面的文字必須匹配不上pattern 反向肯定預查 (?\u0026lt;=pattern) 表示從當前位置開始，預測前面的文字必須匹配上pattern 反向否定預查 (?\u0026lt;!pattern) 表示從當前位置開始，預測前面的文字必須匹配不上pattern   有三個英文字後，才會判斷是否為長度3~50且正確的英文與符號。\nRegex.IsMatch(EnglishName, \u0026#34;@^(?=.*[A-Z].*[A-Z].*[A-Z])[A-Z//.\\\\\\s]{3,50}$\u0026#34;); 每次要寫RE都要查一下怎麼寫XD，希望我下次不要再忘記啦。\n參考 https://www.runoob.com/regexp/regexp-syntax.html https://blog.csdn.net/NAPO687/article/details/110198206\n","date":"2021-12-14T13:08:10+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211214_%E6%AD%A3%E5%89%87%E8%A1%A8%E9%81%94%E5%BC%8F.md/","title":"正則表達式筆記"},{"content":" 介紹  自小時候我就是Halo(最後一戰)系列的鐵桿粉絲了，在最初代XBOX上面不知道重破了好幾遍，這款遊戲也是我唯一想要購買XBOX的理由了，過了超久到了現在，Halo也不再是XBOX獨佔了(除了Halo 5)，其他版本皆已經能在PC上遊玩，如今Halo Infinite也正式推出，這次鐵了心買了XGPU的會員，一次就給他包3年。這三年微軟自家的遊戲都可以直接玩爆，還有EA PLAY可以玩，絕對玩不完的。 \r趕回來結束戰鬥\r\n 省錢  網路上有很多教你怎麼儲XGPU最劃算，但是算一算都還是要幾千元，因為台灣的XGPU價格太高了，國外其他地區的價格可能比台灣便宜上不少，所以自行跨區購買或是請人代儲可能是最划算的方案，但是這些風險都比較高，但是我打開淘寶看到代儲3年只要118人民幣，真的是太香了，直接秒速下訂，但發現淘寶的虛擬物品只能透過中國的銀行卡來進行付款，不支持海外刷卡，或是玉山ATM轉帳，只能去蝦皮找代付，看了幾家都差不多錢，公道價應該是1:5.4台幣，換算下來淘寶代儲只需要台幣637，一年只要200出頭，太划算了。\n 代儲  代儲最好使用小號且要先把密碼隨便改掉，再給淘寶的店家比較安全，店家登入時會再跟你要登入安全碼，我不確定店家是如何把成本壓那麼低的，不過代儲時會看到自己的信箱收到來自微軟的日文信件的付款訊息，應該官方的沒錯，最後記得把密碼改掉。 \r代儲時收到的日文信件\r\n 貪小便宜的下場  沒想到過了半年後，突然發現被偵測到違反Xbox條款及條件，被取消訂閱啦QQ，只好聯繫賣家退款，淘寶店鋪直接倒店找不到商店了，但好在賣家客服還在，也願意按照比例退款(願意退98.5RMB)。 需要聯繫官方客服申請開通退款，經過官方客服漫長的處理(隔天早上)，再次聯繫客服才開通成功，一開始詢問是不是退到我的支付寶，客服說是，結過退完發現是退到代付的人那邊＝＝ 去蝦皮看也發現他倒店了，聊聊五天前上線，希望渺茫Ｒ\n","date":"2021-12-13T17:25:11+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211211_xboxgamepass.md/","title":"XBOX Game Pass Ultimate"},{"content":" 心得(小雷)  沒想到刀劍神域又出劇場版了，我好興奮啊!!上一次看序列爭戰我還在高雄念書，特別跑去市區超遠的高雄大遠百看4dx，那次也是我第一次體驗4dx的威力，那個動態座椅讓我完全融入在畫面裡面，刀刀砍在背上的感覺，刀削的氣流在耳邊噴發，我現在還在激動啊！總之就是回不去了，當時學生票好像是450還500有點忘記了，這個價錢對於學生的我也是不小的金額，但我還是覺得超值得。\n這次去看的電影院是信義威秀，看了一下票價原價要550，這個票價也不是鬧著玩的，身為半個客家人的我，發現蝦皮上面有在賣威秀的招待票一張300元，而且可以看4dx，立馬下定，相見恨晚，太划算了。\n\r用招待票通常是不能拿特典的，但是店員還是發給我，小確幸XD。\r\n刀劍神域Progressive是以亞絲娜作為故事主角出發，講述了進入SAO的原因及第一層的故事，本傳後面出了一堆遊戲但還是沒有比SAO更刺激好看，這個冷飯，真香。劇情還是有做一些修改與本傳不同，多了米特這個角色，她與亞絲娜從最好的朋友，遇到死結時選擇退出隊伍自己離開，到最後互相體諒和好，並走上各自的道路，完美呼應主題曲『前行』的歌詞。\n中間一定要加上桐老爺出來裝逼，帥氣收割一波，整體畫面跟音樂我都很滿意，再加上動態座椅的加持，滿分10分我給9.5分，要是能有60FPS那就完美了，2022年也要出另一部劇場版，沒意外也要看4dx!\n","date":"2021-12-09T13:29:52+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211207_%E5%88%80%E5%8A%8D%E7%A5%9E%E5%9F%9Fprogressive.md/","title":"刀劍神域Progressive 無星夜的詠嘆調 劇場版"},{"content":" 前情提要  在過去學生時期的時候就接觸了股票，總覺得要錢滾錢才能財富自由，把打工的錢都拿去玩看看，當時的選股策略是\n1.股價夠低(因為本金太小買不起太貴的股票，每一次買股票都是All in)\n2.看起來現在在低檔，低到不能再低的感覺\n當時All in買了陽明4塊多還5塊，沒過幾天不知怎麼就噴到漲停，抓到一個低買高賣的節奏，沒多久就把它出清了，獲利4000$多，後來又聽朋友建議去買光學鏡頭股玉晶光，也賺了好幾千，我該不會其實很適合玩股票吧XD，直到我膝蓋中了一箭，南亞科賠20000元，沒想到那麼慘，之後就退出股海了。\n直到現在全球股市一直突破新高，並且出社會領薪水的時候，我，再次回歸！等等這不會是高點的訊號吧QQ\n對了，這邊不做任何投資建議喔，單純心得分享。\n 啟蒙  領了薪水後，只能說錢真的賺，現在年輕人基本上沒什麼希望，光活著就已經費盡全力，每週40小時的生命賣給公司，扣掉基本開銷、房租、伙食，可以花的錢也就一萬多吧，還沒有任何娛樂，活著，卻像是個死人，但想到父母為了我也把自己的生命販賣給公司，只為了能讓我有好的生活，我又有什麼好藉口不去努力呢？\n看了一本關於理財的書籍『我用死薪水輕鬆理財賺千萬』，讓我了解的資產配置、再平衡與指數投資的基本概念，書中的內容都淺顯易懂，沒有什麼難以離解的東西。之後也看了網路上許多的文章與影片，清流君、魯爸、yp筆記、多拉王與伯格頭投資指南，都讓我堅信指數投資是個GOOD SHIT~\n 伯格頭的投資指南\n evelop a workable plan Invest early and ofter Never bear too much or too little risk Diversify Never try to time the market Use index funds when possible Keep costs low Minimize taxes Invest with simplicity Stay the course    開戶準備  伯格頭的投資指南第7條，Keep costs low，盡可能地減少投資成本。\n成本最低的應該是台股定期定額(新光證券20000內，手續費1元)\n海外複委託美股(富邦證券，0.12%，低消12美金)\n海外複委託英股(富邦證券，0.15%，低消15美金)\n海外券商(電匯費用一次800吧(不確定沒用過)，交易手續費趨近於0)\n金額大的話海外券商比複委託還要省很多，不過我自己錢還沒有那麼多，現在階段用復委託會比較便宜一點。\n 投資標的  伯格頭的投資指南第4條，Diversify，多樣性。\nETF一籃子的股票，含有各個領域與不同公司的股票\n伯格頭的投資指南第6條，Use index funds when possible，如果可能的話使用指數基金。\n006208 可以把它想成內扣費用較低的0050\n伯格頭的投資指南第8條，Minimize taxes，上班族繳太多稅了，少繳一點。\nVWRD 可以把它想成英國版的VT，但少了小型股部位，稅也比較少了。\n 投資組合  伯格頭的投資指南第9條，Invest with simplicity，簡單才好管理。\n由於使用復委託，標的太多交易成本會太高，所以我是沒有配債的部位，先用高利率活存來代替，未來在考慮要不要加入債券部位。\n股票部位：VWRD 80%、006208 20%\n 投入時間  伯格頭的投資指南第5條，Never try to time the market，錢夠就丟，我就看他能不能長出一朵花。\n持有越久的現金機會成本越大，應該儘早投入。\nVWRD每3~4個月手動操作買入\n006208定期定額買入\n 未來  薪水高，累積財富的速度也才會快，專注於本業，提升自己的能力與價值。\n伯格頭的投資指南第10條，Stay the course，持之以恆。\n一直堅持下去就對了，如果心中有所疑惑，那可能是投資組合不適合自己，要再做調整。\n\r\n","date":"2021-12-06T10:55:10+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211206_%E6%8C%87%E6%95%B8%E6%8A%95%E8%B3%87.md/","title":"指數投資"},{"content":" 介紹  接下來的筆記是根據線上課程Microservices Architecture and Implementation on .NET 5所記錄下來的，講者的口音有點重，聽得有點吃力，他這個專案基本上重做微軟提供的範例專案，電商系統，完美呈現微服務的使用與他的優點，一共把服務切成四個主要的服務，Catalog(商品目錄系統)、Basket(購物車系統)、Discount(折扣系統)、Ordering(訂單系統)，並分別使用不同的資料庫(mongodb、redis、PostgreSQL、MSSQL)、不同的傳輸協定(Rest API、Grpc)、不同的架構(多層式架構、簡潔架構)，最後使用Docker容器化，把他們都整合在一起運作。\n\r整個系統的架構圖\r\n工作一陣子了，維護的系統基本也都上手了(龐大的Web Service架構)，但還有許多前人的智慧，一時之間是很難理解的XD，這時有一個乾淨的架構，或許上手的時間就可以更短了。\n Domain Layer  建立一個訂單系統使用Clean Architecture\n依照分層創建各個不同的Project， Ordering.API Ordering.Domain Ordering.Application Ordering.infrastructure \r整個系統的架構圖\r\n建立相依關係Project右鍵 \u0026gt;\u0026gt; Add \u0026gt;\u0026gt; Reference \r相依關係\r\n詳細定義與設計可以參考\nhttps://ithelp.ithome.com.tw/articles/10223150 https://ithelp.ithome.com.tw/articles/10223595\n 開發Ordering.Domain Layer  我們要先建立兩個資料夾Common、Entities\nCommon 其中Common放的是我們建立Entity的基礎，含有兩個abstract class，EntityBase、ValueObject，\n//我們每一個Entity都要的屬性 public abstract class EntityBase { public int Id { get; protected set; } public string CreatedBy { get; set; } public DateTime CreatedDate { get; set; } public string LastModifiedBy { get; set; } public DateTime? LastModifiedDate { get; set; } } Entities 建立Order物件並繼承EntityBase\n//訂單必須要的屬性 public class Order : EntityBase { public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } }  參考  簡潔架構 Application Layer\n簡潔架構 Infrastructure Layer\nhttps://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/\nhttps://rwang.medium.com/%E5%86%8D%E8%AE%80%E6%95%B4%E6%BD%94%E6%9E%B6%E6%A7%8B-clean-architecture-12b562472c3b\n","date":"2021-12-02T15:52:49+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021202_%E7%B0%A1%E6%BD%94%E6%9E%B6%E6%A7%8Bdomain.md/","title":"簡潔架構 Domain Layer"},{"content":" 筆記  CQRS(Command Query Responsibility Segregation)命令查詢分隔，目前看起來就是不再需要IRepository了，把它拆成Command(負責寫入資料庫的部分)與Query(只負責讀取的部分)。\n可以增加資料庫的效能，Command的部分則會透過event的形式記錄起來再同步到DB上面。\n我還是偏好原本的方法啊XD\n 參考  https://ithelp.ithome.com.tw/articles/10237458\n","date":"2021-12-01T11:08:44+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021201_cqrs.md/","title":"CQRS"},{"content":" 關於DDD  隨著科技進步，需求也是越來越複雜，更多的是需要專業領域人員與開發人員共同協作\nDDD是一種基於領域知識來解決複雜業務問題的軟體開發方法論。\n Ubiquitous Language  使用通用語言就很重要了，講人話，減少溝通成本。 ex:下訂單大家就聽得懂，別講些什麼call Order API、B2C之類的\n Anemic Model  Anemic Model貧血模型是指那些只有getter、setter沒有行為能力的模型\nLF2邪鬼(地獄火焰)防下功+防上跳+防前跳+防下跳+防上功 為例\nDevil Max = new Devil(); //使用地獄火焰 Max.Defence().Down().Attack(); Max.Defence().Up().Jump(); Max.Defence().Left().Jump(); Max.Defence().Down().Jump(); Max.Defence().Up().Attack(); 導入DDD與專家討論過後，未來開發的人員直接看程式碼也看得懂在幹嘛\nDevil Max = new Devil(); Max.HellFire();  與微服務的關係  很多時候Micorservices不知道怎麼做切割，這時候DDD就提供一個很好的方向去做業務分割。\n 參考  https://ithelp.ithome.com.tw/articles/10216645 https://forum.gamer.com.tw/C.php?bsn=7648\u0026snA=3299\n","date":"2021-11-30T14:30:40+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021130_ddd.md/","title":"Domain Driven Design 領域驅動設計"},{"content":" SOLID原則  Single responsibility principle 單一功能原則 認為一個class就應該只有一個任務要做，不做其他任務以外的事情，過去是很多不同的需求都用同一個Service，單一功能原則則是提供各種不同的Use Case給各個需求。 \rSRP示意圖\r\nOpen/ closed principle 開閉原則 一個class或Function對於他的擴展是開放的，但是對於修改是封閉的，意思就是不改變他的行為，但是可以增加新的功能。 就像是電動理髮刀，可以換上各種不同的刀頭(擴展)，但是機身本體是不能修改的(封閉)。\nLiskov substitution principle 里氏替換原則 程式中的物件應該是可以在不改變正確性的前提下被他的子類所替換的概念，我們在使用「繼承」時，重要的是重複使用 (reuse) 已經寫好的行為，而不是將所有繼承的行為全部覆蓋。\nInterface segregation principle 介面隔離原則 很多個客製化的interface比一個通用的interface還要來得更好管理，例如一個政客interface有提出政見()、拜票()、努力工作()，但事實上不是每一個政客都想實作努力工作XD，所以應該方別建兩個interface，政客介面:提出政見()、拜票()與工作介面:努力工作()。\nDependency inversion principle 依賴反轉原則 各個class之間的相依性應該越低越好，上層的class不該依賴下層的class \rDIP示意圖\r\n SoC(Separation of concerns) 關注點分離  關注點分離表示，以前端的例子來說，在過去我們是以「關注技術」的方式來分離成HTML、CSS、JavaScript，現今主流框架Vue則是採用「關注元件」的方式來分離，每一個Component都有各自的HTML、CSS、JavaScript。\n 參考  https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1) https://medium.com/@f40507777/%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87-open-closed-principle-31d61f9d37a5 https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/%E7%AC%AC-10-%E7%AB%A0-%E9%A1%9E%E5%88%A5-clean-code-1c7898d11cd7\n","date":"2021-11-29T16:10:40+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021129_solid%E5%8E%9F%E5%89%87.md/","title":"SOLID、SoC"},{"content":" 筆記  可以輕鬆的轉換兩個class，讓程式碼變得更加簡短乾淨。\nmessage CouponModel { int32 id = 1; string productName = 2; string description = 3; int32 amount = 4; } 在Grpc定義的優戶券模型\npublic class Coupon { public int Id { get; set; } public string ProductName { get; set; } public string Description { get; set; } public int Amount { get; set; } } 我們自己定義的模型\n原先轉換需要像是這個樣子\nCoupon coupon; CouponModel cm = new CouponModel{ id = coupon.Id, productName = coupon.ProductName, description = coupon.Description, amount = coupon.Amount } 使用Mapper後只要\nCoupon coupon; CouponModel cm = _mapper.Map\u0026lt;CouponModel\u0026gt;(coupon);  如何使用  1.Nuget搜尋並下載AutoMapper.Extensions.Microsoft.DependencyInjection\n2.在Startup註冊AutoMapper服務\npublic void ConfigureServices(IServiceCollection services) { services.AddAutoMapper(typeof(Startup)); } 3.建立轉換的Porfile\npublic class CouponProfile :Profile //繼承Profile { public CouponProfile() { //讓Coupon與CouponModel可以方便地互相轉換  CreateMap\u0026lt;Coupon, CouponModel\u0026gt;().ReverseMap(); } } 4.依賴注入到需要使用的class裡\nprivate readonly IMapper _mapper; public DiscountService(IMapper mapper) { _mapper = mapper; } 5.享受AutoMapper帶來的便利~~\n 參考  https://igouist.github.io/post/2020/07/automapper/\n","date":"2021-11-25T14:55:07+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211125_automapper.md/","title":"AutoMapper - DI Version"},{"content":" 筆記  Grpc是google開發的rpc(Remote Procedure Call)框架，用於電腦與電腦之間的溝通，就像電腦A呼叫電腦B做事情，電腦B做好事情後把結果回傳給電腦A，與一般的api不同的地方在於，電腦A、B在進行Grpc溝通前，都必須有protocal buffers檔案來把格式與方法定義清楚，並使用HTTP/2進行傳輸，快速、低延遲、支持串流。\n protocal buffers 檔案  在VS裡面，Add \u0026raquo; New Project \u0026raquo; 選gRPC Service \u0026raquo; \u0026hellip;一些基本設定\n生成新gRPC Service後，裡面會有.proto檔案\nsyntax = \u0026#34;proto3\u0026#34;;//使用的protocal buffers版本  option csharp_namespace = \u0026#34;MyFirstGrpc.Grpc\u0026#34;;//命名空間  package greeter; // 定義交換資料的格式 message HelloRequest { string name = 1; } // 定義交換資料的格式 message HelloReply { string message = 1; } // 定義呼叫api的方法 service Greeter { // SayHello方法需要輸入參數(HelloRequest格式) 會回傳(HelloReply格式)  rpc SayHello (HelloRequest) returns (HelloReply); }  AppSettings 使用Http2  { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Kestrel\u0026#34;: { \u0026#34;EndpointDefaults\u0026#34;: { \u0026#34;Protocols\u0026#34;: \u0026#34;Http2\u0026#34; } } } 我們可以看到在AppSettings裡Protocols是採用Http2\n 產生Service class檔案  如果設定都沒有錯的話，會在MyFirstGrpc.Grpc/obj/Debug/net5.0/Protos產生Greet.cs與GreetGrpc.cs\n若資料夾內沒有產生cs檔，很有可能是專案檔MyFirstGrpc.Grpc.csproj裡面設定有問題。\n確保有\u0026lt;Protobuf Include=\u0026quot;Protos\\greet.proto\u0026quot; GrpcServices=\u0026quot;Server\u0026quot; /\u0026gt;對.proto做編譯\n//參考的.csproj \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;None Remove=\u0026#34;Protos\\greeter.proto\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Grpc.AspNetCore\u0026#34; Version=\u0026#34;2.32.0\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;Protobuf Include=\u0026#34;Protos\\greeter.proto\u0026#34; GrpcServices=\u0026#34;Server\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;  GreeterService 實作  namespace MyFirstGrpc.Grpc { public class GreeterService : Greeter.GreeterBase { private readonly ILogger\u0026lt;GreeterService\u0026gt; _logger; public GreeterService(ILogger\u0026lt;GreeterService\u0026gt; logger) { _logger = logger; } public override Task\u0026lt;HelloReply\u0026gt; SayHello(HelloRequest request, ServerCallContext context) { return Task.FromResult(new HelloReply { Message = $\u0026#34;Hello {request.Name}\u0026#34; }); } } } 在Services/GreeterService.cs下\n繼承自動產生的Greeter下的GreeterBase並將其覆寫，最主要的邏輯也是寫在這邊。\nSayHello方法需要輸入參數(HelloRequest格式) 會回傳(HelloReply格式)\nTip:輸入override按下空白，VS會自動把可以override的class顯示出來。\n 註冊Grpc服務  public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddGrpc(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseRouting(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapGrpcService\u0026lt;GreeterService\u0026gt;(); endpoints.MapGet(\u0026#34;/\u0026#34;, async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909\u0026#34;); }); }); } } 在startup.cs下 透過services.AddGrpc();註冊Grpc服務，方可使用Grpc。 透過endpoints.MapGrpcService\u0026lt;GreeterService\u0026gt;();把所有Grpc服務部署到Routing Pipeline裡\n 新增Grpc服務的reference  購物車的功能需要導入折價券.Grpc的服務\n購物車是Client端\n折價券是Server端\nVS for Mac在專案下面就可以直接看到Connected Services Windows則是右鍵 \u0026raquo; Add \u0026raquo; connected services\n選取購物車專案的connected services \u0026raquo; Add new Grpc service reference \u0026raquo; Add \u0026raquo; 參照折價券.Grpc裡面的.proto \u0026raquo; 選擇Client模式\n執行完後，可以看到.csproj多了Grpc服務、專案下也多了protos\n\u0026lt;Protobuf Include=\u0026#34;..\\..\\Discount\\Discount.Grpc\\Discount.Grpc\\Protos\\discount.proto\u0026#34; GrpcServices=\u0026#34;Client\u0026#34;\u0026gt; \u0026lt;OutputDir\u0026gt;obj\\Debug\\net5.0\\\u0026lt;/OutputDir\u0026gt; \u0026lt;Link\u0026gt;Protos\\discount.proto\u0026lt;/Link\u0026gt; \u0026lt;/Protobuf\u0026gt; 建置專案後，也會產生ProtoServiceClient等cs檔\n 參考  https://pjchender.dev/golang/grpc-getting-started/\nhttps://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-6.0\u0026tabs=visual-studio\n","date":"2021-11-24T10:12:35+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211124_grpcmemo.md/","title":"Grpc 筆記"}]