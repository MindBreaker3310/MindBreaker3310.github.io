[{"content":"使用Grpc服務  前情提要  購物車的功能需要導入折價券.Grpc的服務\n購物車是Client端\n折價券是Server端\n 新增Grpc服務的reference  VS for Mac在專案下面就可以直接看到Connected Services Windows則是右鍵 \u0026raquo; Add \u0026raquo; connected services\n選取購物車專案的connected services \u0026raquo; Add new Grpc service reference \u0026raquo; Add \u0026raquo; 參照折價券.Grpc裡面的.proto \u0026raquo; 選擇Client模式\n執行完後，可以看到.csproj多了Grpc服務、專案下也多了protos\n\u0026lt;Protobuf Include=\u0026#34;..\\..\\Discount\\Discount.Grpc\\Discount.Grpc\\Protos\\discount.proto\u0026#34; GrpcServices=\u0026#34;Client\u0026#34;\u0026gt; \u0026lt;OutputDir\u0026gt;obj\\Debug\\net5.0\\\u0026lt;/OutputDir\u0026gt; \u0026lt;Link\u0026gt;Protos\\discount.proto\u0026lt;/Link\u0026gt; \u0026lt;/Protobuf\u0026gt; 建置專案後，也會產生ProtoServiceClient等cs檔\n 參考  https://pjchender.dev/golang/grpc-getting-started/ https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-6.0\u0026tabs=visual-studio\n","date":"2021-11-25T15:57:43+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021125_%E4%BD%BF%E7%94%A8grpc%E6%9C%8D%E5%8B%99.md/","title":"使用Grpc服務"},{"content":"AutoMapper 筆記  簡單介紹  可以輕鬆的轉換兩個class，讓程式碼變得更加簡短乾淨。\n 範例  message CouponModel { int32 id = 1; string productName = 2; string description = 3; int32 amount = 4; } 在Grpc定義的優戶券模型\npublic class Coupon { public int Id { get; set; } public string ProductName { get; set; } public string Description { get; set; } public int Amount { get; set; } } 我們自己定義的模型\n原先轉換需要像是這個樣子\nCoupon coupon; CouponModel cm = new CouponModel{ id = coupon.Id, productName = coupon.ProductName, description = coupon.Description, amount = coupon.Amount } 使用Mapper後只要\nCoupon coupon; CouponModel cm = _mapper.Map\u0026lt;CouponModel\u0026gt;(coupon);  如何使用  1.Nuget搜尋並下載AutoMapper.Extensions.Microsoft.DependencyInjection\n2.在Startup註冊AutoMapper服務\npublic void ConfigureServices(IServiceCollection services) { services.AddAutoMapper(typeof(Startup)); } 3.建立轉換的Porfile\npublic class CouponProfile :Profile //繼承Profile { public CouponProfile() { //讓Coupon與CouponModel可以方便地互相轉換  CreateMap\u0026lt;Coupon, CouponModel\u0026gt;().ReverseMap(); } } 4.依賴注入到需要使用的class裡\nprivate readonly IMapper _mapper; public DiscountService(IIMapper mapper) { _mapper = mapper; } 5.享受AutoMapper帶來的便利~~\n 參考  https://igouist.github.io/post/2020/07/automapper/\n","date":"2021-11-25T14:55:07+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211125_automapper.md/","title":"AutoMapper - DI Version"},{"content":"Grpc 筆記  簡單介紹  Grpc是google開發的rpc(Remote Procedure Call)框架，用於電腦與電腦之間的溝通，就像電腦A呼叫電腦B做事情，電腦B做好事情後把結果回傳給電腦A，與一般的api不同的地方在於，電腦A、B在進行Grpc溝通前，都必須有protocal buffers檔案來把格式與方法定義清楚，並使用HTTP/2進行傳輸，快速、低延遲、支持串流。\n protocal buffers 檔案  syntax = \u0026#34;proto3\u0026#34;;//使用的protocal buffers版本  option csharp_namespace = \u0026#34;MyFirstGrpc.Grpc\u0026#34;;//命名空間  package greeter; // 定義交換資料的格式 message HelloRequest { string name = 1; } // 定義交換資料的格式 message HelloReply { string message = 1; } // 定義呼叫api的方法 service Greeter { // SayHello方法需要輸入參數(HelloRequest格式) 會回傳(HelloReply格式)  rpc SayHello (HelloRequest) returns (HelloReply); }  AppSettings 使用Http2  { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Kestrel\u0026#34;: { \u0026#34;EndpointDefaults\u0026#34;: { \u0026#34;Protocols\u0026#34;: \u0026#34;Http2\u0026#34; } } } 我們可以看到在AppSettings裡Protocols是採用Http2\n 產生Service class檔案  如果設定都沒有錯的話，會在MyFirstGrpc.Grpc/obj/Debug/net5.0/Protos產生Greet.cs與GreetGrpc.cs\n若資料夾內沒有產生cs檔，很有可能是專案檔MyFirstGrpc.Grpc.csproj裡面設定有問題。\n確保有\u0026lt;Protobuf Include=\u0026quot;Protos\\greet.proto\u0026quot; GrpcServices=\u0026quot;Server\u0026quot; /\u0026gt;對.proto做編譯\n//參考的.csproj \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;None Remove=\u0026#34;Protos\\greeter.proto\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Grpc.AspNetCore\u0026#34; Version=\u0026#34;2.32.0\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;Protobuf Include=\u0026#34;Protos\\greeter.proto\u0026#34; GrpcServices=\u0026#34;Server\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;  GreeterService 實作  namespace MyFirstGrpc.Grpc { public class GreeterService : Greeter.GreeterBase { private readonly ILogger\u0026lt;GreeterService\u0026gt; _logger; public GreeterService(ILogger\u0026lt;GreeterService\u0026gt; logger) { _logger = logger; } public override Task\u0026lt;HelloReply\u0026gt; SayHello(HelloRequest request, ServerCallContext context) { return Task.FromResult(new HelloReply { Message = $\u0026#34;Hello {request.Name}\u0026#34; }); } } } 在Services/GreeterService.cs下\n繼承自動產生的Greeter下的GreeterBase並將其覆寫，最主要的邏輯也是寫在這邊。\nSayHello方法需要輸入參數(HelloRequest格式) 會回傳(HelloReply格式)\nTip:輸入override按下空白，VS會自動把可以override的class顯示出來。\n 註冊Grpc服務  public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddGrpc(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseRouting(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapGrpcService\u0026lt;GreeterService\u0026gt;(); endpoints.MapGet(\u0026#34;/\u0026#34;, async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909\u0026#34;); }); }); } } 在startup.cs下 透過services.AddGrpc();註冊Grpc服務，方可使用Grpc。 透過endpoints.MapGrpcService\u0026lt;GreeterService\u0026gt;();把所有Grpc服務部署到Routing Pipeline裡\n 參考  https://pjchender.dev/golang/grpc-getting-started/ https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-6.0\u0026tabs=visual-studio\n","date":"2021-11-24T10:12:35+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211124_grpcmemo.md/","title":"Grpc 筆記"},{"content":"189. Rotate Array  題目  ‎給一個陣列，將陣列向右旋轉k步。\n 範例  Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  解答  public class Solution { public void Rotate(int[] nums, int k) { if (nums.Length \u0026lt;= 1) { return; } k = k % nums.Length; Solution.Reverse(nums, 0, nums.Length - 1); Solution.Reverse(nums, 0, k - 1); Solution.Reverse(nums, k, nums.Length - 1); } public static void Reverse(int[] arr, int low, int high) { while (low \u0026lt; high) { int temp = arr[low]; arr[low] = arr[high]; arr[high] = temp; low++; high--; } } }  筆記  假設[1,2,3,4,5,6,7], k = 3\n先寫一個可以使陣列反轉的方法\n將整個陣列翻轉 [7,6,5,4,3,2,1] 接著翻轉0到k-1的部分 [5,6,7,4,3,2,1] 再翻轉剩下的部分 [5,6,7,1,2,3,4]\n 參考  https://leetcode.com/problems/rotate-array/\n","date":"2021-10-19T20:11:06+08:00","permalink":"https://mindbreaker3310.github.io/posts/rotate-array/","title":"Rotate Array"},{"content":"977. Squares of a Sorted Array  題目  給一個由排序到大的陣列，回傳每個數值都平方的排序陣列。\n 範例  Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121]  解答  public class Solution { public int[] SortedSquares(int[] nums) { int[] ans = new int[nums.Length]; int i = 0; int j = nums.Length - 1; int p = j; while (i \u0026lt;= j) { if (Math.Abs(nums[i]) \u0026gt; Math.Abs(nums[j])) { ans[p] = (int)Math.Pow(nums[i], 2); i++; } else { ans[p] = (int)Math.Pow(nums[j], 2); j--; } p--; } return ans; } }  筆記  設立三個指標 i:nums的第一個index j:nums的最後一個index p:nums要賦予值index，由最後面開始。\n因為平方的關係，只要絕對值越大，代表該數平方後會越大，較大的那邊，數值會被放在nums[p]的位置，然後移動該指標。\n 參考  https://leetcode.com/problems/squares-of-a-sorted-array/\n","date":"2021-10-19T20:07:04+08:00","permalink":"https://mindbreaker3310.github.io/posts/squares-of-a-sorted-array/","title":"Squares of a Sorted Array"},{"content":"88. Merge Sorted Array  題目  給予兩個非零部分由小到大排序的陣列nums1與nums2，m與n分別代表前面兩個陣列的長度。\n目標要將nums1與nums2合併，替換掉nums1內的0。\n 範例  Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1].  解答  public class Solution { public void Merge(int[] nums1, int m, int[] nums2, int n) { int p = m + n - 1; m = m - 1; n = n - 1; while (m \u0026gt;= 0 \u0026amp;\u0026amp; n \u0026gt;= 0) { if (nums1[m] \u0026gt;= nums2[n]) { nums1[p] = nums1[m]; m--; } else { nums1[p] = nums2[n]; n--; } p--; } while (n \u0026gt;= 0) { nums1[p] = nums2[n]; n--; p--; } } }  筆記  設立三個指標 m:nums1最後一個非零數的index p:nums1最後一個index n:nums2最後一個數的index\n因為這兩個陣列都是由小排到大的，所以比較兩個陣列最大的值放到p的位置。看圖可能比較快XD\n 參考  https://leetcode.com/problems/merge-sorted-array/\n","date":"2021-10-19T20:03:08+08:00","permalink":"https://mindbreaker3310.github.io/posts/merge-sorted-array/","title":"Merge Sorted Array"},{"content":"1. Two Sum  題目  給一整數陣列與目標數，找出陣列中的兩個數值相加會等於目標數，並回傳這兩個數的index。\n只會有一個解，且不同重複使用相同的元素\n 範例  Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Input: nums = [3,2,4], target = 6 Output: [1,2]  解答  public class Solution { public int[] TwoSum(int[] nums, int target) { Dictionary\u0026lt;int, int\u0026gt; dict = new Dictionary\u0026lt;int, int\u0026gt;(); for (int i = 0; i \u0026lt; nums.Length; i++) { if (dict.ContainsKey(target - nums[i])) return new int[] { i, dict[target - nums[i]] }; else if (!dic.ContainsKey(nums[i])) dict.Add(nums[i], i); } return new int[2]; } }  筆記  建立個一Dictionary來存放已經找過的數值跟他的index，每一個迭代都先計算該數nums[i]與目標數target的差，再回去找是否有存在於Dict內。\n 參考  https://leetcode.com/problems/two-sum/\n","date":"2021-10-19T20:00:03+08:00","permalink":"https://mindbreaker3310.github.io/posts/two-sum/","title":"Two Sum"},{"content":"278. First Bad Version  題目  ‎給一個整數陣列，找到\u0026quot;連續\u0026quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。\n 範例  Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -\u0026gt; false call isBadVersion(5) -\u0026gt; true call isBadVersion(4) -\u0026gt; true Then 4 is the first bad version. Input: n = 1, bad = 1 Output: 1  解答  public class Solution : VersionControl { public int FirstBadVersion(int n) { for (int i = n; i \u0026gt;= 1; i--) { if (!IsBadVersion(i)) { return i + 1; } } return 1; } } 直覺但是too slow! 搭配使用上一篇學習的Binary Search\npublic class Solution : VersionControl { public int FirstBadVersion(int n) { int low = 1; int high = n; while(low \u0026lt; high) { int mid = low + (high - low) / 2; if(IsBadVersion(mid)) { high = mid; } else { low = mid + 1; } } return high; } }  筆記  之所以while(low \u0026lt; high)與high = mid而不是while(low \u0026lt;= high)與high = mid -1，因為當mid是BadVersion時，前一個可能也是BadVersion，所以我們確保high都是BadVersion的範圍，進一步逼近low的。\n 參考  https://leetcode.com/problems/first-bad-version/\n","date":"2021-10-19T13:26:30+08:00","permalink":"https://mindbreaker3310.github.io/posts/first-bad-version/","title":"First Bad Version"},{"content":"53. Maximum Subarray  題目  ‎給一個整數陣列，找到\u0026quot;連續\u0026quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。\n 範例  Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6 Input: nums = [1] Output: 1  解答  public class Solution { public int MaxSubArray(int[] nums) { int currentSum = 0; int maxSum = nums[0]; for (int i = 0; i \u0026lt; nums.Length; i++) { currentSum += nums[i]; if (nums[i] \u0026gt; currentSum) { currentSum = nums[i]; } if (currentSum \u0026gt; maxSum) { maxSum = currentSum; } } return maxSum; } }  筆記  currentSum代表從前面往後加的總和，如果當nums[i]比前面加的總和還大時，那就從nums[i]開始重加currentSum = nums[i]\n當currentSum比maxSum還要大時，更新最大值\n 參考  https://leetcode.com/problems/maximum-subarray/\n","date":"2021-10-19T12:31:43+08:00","permalink":"https://mindbreaker3310.github.io/posts/maximum-subarray/","title":"Maximum Subarray"},{"content":"217. Contains Duplicate  題目  給一整數陣列，如果任何值在陣列中‎‎至少出現兩次‎‎，回傳true，否則回傳false。\n 範例  Input: nums = [1,2,3,1] Output: true Input: nums = [1,2,3,4] Output: false  解答  public class Solution { public bool ContainsDuplicate(int[] nums) { Array.Sort(nums); for (int i = 0; i \u0026lt; nums.Length - 1; i++) { if (nums[i] == nums[i + 1]) { return true; } } return false; } }  筆記  很直覺，先排序好陣列後，若有連續兩個數字相同，及代表有數值重複出現。\n 參考  https://leetcode.com/problems/contains-duplicate/\n","date":"2021-10-19T11:51:58+08:00","permalink":"https://mindbreaker3310.github.io/posts/contains-duplicate/","title":"Contains Duplicate"},{"content":"35. Search Insert Position  題目  ‎給一個整數陣列，找到\u0026quot;連續\u0026quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。\n 範例  Input: nums = [1,3,5,6], target = 5 Output: 2 Input: nums = [1,3,5,6], target = 2 Output: 1  解答  public class Solution { public int SearchInsert(int[] nums, int target) { int low = 0; int high = nums.Length - 1; while (low \u0026lt;= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] \u0026lt; target) { low = mid + 1; } else if (nums[mid] \u0026gt; target) { high = mid - 1; } } return low; } }  筆記  基本上與Binary Search的用法沒有區別，只差在return low的原因是當low \u0026lt;= high時，low的位置剛好會在target應該要在的位置上。\n 參考  https://leetcode.com/problems/search-insert-position/\n","date":"2021-10-18T22:16:12+08:00","permalink":"https://mindbreaker3310.github.io/posts/search-insert-position/","title":"Search Insert Pposition"},{"content":"704. Binary Search  題目  給一個由小到大排序的整數陣列nums與一個目標整數target，如果target存在於nums之中，回傳該目標數的index，否則回傳-1。\n時間複雜度必須為O(log n)。\n 範例  Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1  解答  public class Solution { public int Search(int[] nums, int target) { int low = 0; int high = nums.Length - 1; while(low \u0026lt;= high) { int mid = low + (high - low)/2; if(nums[mid] == target) { return mid; } else if(nums[mid] \u0026lt; target) { low = mid + 1; } else { high = mid - 1; } } return -1; } }  筆記  概念就是每一次都取low與high範圍內最中間的值nums[mid]並與目標target比較，如果與相等就代表找到目標數，回傳該數索引值mid，若target比較大，拉高下限值low就改設為mid + 1，反之target比較小，降低上限值high設為mid - 1。如下圖所示。\n\rpivot就是mid\r\nwhile(low \u0026lt;= high) 當一直找不到時low最終會超過high\n求兩個int的平均數時，最好不要使用(low + high)/2，因為當low + high相加的時候大於int.MaxValue (2^31 - 1)時會overflow，使用 int mid = low + ((high - low) / 2);就可以解決這個問題\n 參考  https://leetcode.com/problems/binary-search/ https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html\n","date":"2021-10-18T20:10:11+08:00","permalink":"https://mindbreaker3310.github.io/posts/binary-serarch/","title":"Binary search algorithm"}]