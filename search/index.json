[{"content":"windows排程紀錄主機磁碟狀態  取得磁碟狀態  工作上總是一堆鳥事，在甲方裡工作有時候又要處理一些完全沒有意義的雜事，浪費時間。\n總之因為不明原因，我需要每週紀錄主機的磁碟剩餘容量百分比\u0026hellip;\n要取得磁碟訊息很簡單，使用System.IO的DriveInfo.GetDrives()可以取得所有磁碟，再把DriveInfo的屬性取出來\nstring diskStatus = \u0026#34;\u0026#34;; DriveInfo[] allDrives = DriveInfo.GetDrives(); foreach (DriveInfo d in allDrives) { if (d.IsReady == true)//確定磁碟就緒  { int freePercent = (int)(d.TotalFreeSpace / (float)d.TotalSize * 100); diskStatus += $\u0026#34; {d.Name}{freePercent} \u0026#34; } }  寫入紀錄  這邊一切以簡單為主，直接用寫入文字檔的方式來進行\n//如果有額外輸入檔案路徑的話，就把第一個參數當作路徑，沒有就丟在桌面 //若不想在排程器那裡設定開始位置的話，就用絕對路徑吧。 string path = args.Length == 1 ? args[0] : \u0026#34;DiskLog.txt\u0026#34;; //記錄時間 string now = DateRime.Now.ToString(\u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;); using StreamWriter file = new (path, append: true); file.WriteLine($\u0026#34;{now}\u0026gt;\u0026gt; {diskStatus}\u0026#34;);  新增排程  這邊基本就點點滑鼠就搞定了\n電腦管理 \u0026raquo; 工作排程器 \u0026raquo; 建立工作\n輸入名稱\n觸發程序 \u0026raquo; 新增 \u0026raquo; 每週\n動作 \u0026raquo; 新增 \u0026raquo; 程式或指令碼(選擇我們程式的exe檔) \u0026raquo; 新增引數(輸入檔案路徑) \u0026raquo; 開始位置(預設為C:\\WINDOWS\\System32)\n 加上錯誤處理  沒什麼意外是不會錯啦，但總是有意外XD，加個try..catch處理就好，最後大概如下。\ntry { string diskStatus = \u0026#34;\u0026#34;; DriveInfo[] allDrives = DriveInfo.GetDrives(); foreach (DriveInfo d in allDrives) { if (d.IsReady == true)//確定磁碟就緒  { int freePercent = (int)(d.TotalFreeSpace / (float)d.TotalSize * 100); diskStatus += $\u0026#34; {d.Name}{freePercent} \u0026#34; } } //如果有額外輸入檔案路徑的話，就把第一個參數當作路徑，沒有就丟在桌面  //若不想在排程器那裡設定開始位置的話，就用絕對路徑吧。  string path = args.Length == 1 ? args[0] : \u0026#34;DiskLog.txt\u0026#34;; //記錄時間  string now = DateRime.Now.ToString(\u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;); using StreamWriter file = new (path, append: true); file.WriteLine($\u0026#34;{now}\u0026gt;\u0026gt; {diskStatus}\u0026#34;); } catch(Exception ex) { Console.WriteLine(ex); Console.ReadKey();//卡個畫面 }  參考  https://docs.microsoft.com/zh-tw/dotnet/api/system.io.driveinfo.getdrives?view=net-6.0\n","date":"2021-12-17T17:09:56+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211217_windows%E6%8E%92%E7%A8%8B%E7%B4%80%E9%8C%84%E4%B8%BB%E6%A9%9F%E7%A3%81%E7%A2%9F%E7%8B%80%E6%85%8B.md/","title":"windows排程紀錄主機磁碟狀態"},{"content":"簡潔架構 Application Layer  Application Layer  注重於商業需求而不是實作一些外部系統的東西，DB之類的。 顧客需要用自己的名子取得訂單\n有三個主要的資料夾Contracts、Features、Behaviors，\n Contracts  存放各Services的interface\nPersistence 基本非同步Repository介面\n//泛型T必需繼承Domina Layer的EntityBase(Id、createdBy、createDate、LastModifiedDate等等的東西) public interface IAsyncRepository\u0026lt;T\u0026gt; where T : EntityBase { Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAllAsync(); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, string includeString = null, bool disableTracking = true); Task\u0026lt;IReadOnlyList\u0026lt;T\u0026gt;\u0026gt; GetAsync(Expression\u0026lt;Func\u0026lt;T, bool\u0026gt;\u0026gt; predicate = null, Func\u0026lt;IQueryable\u0026lt;T\u0026gt;, IOrderedQueryable\u0026lt;T\u0026gt;\u0026gt; orderBy = null, List\u0026lt;Expression\u0026lt;Func\u0026lt;T, object\u0026gt;\u0026gt;\u0026gt; includes = null, bool disableTracking = true); Task\u0026lt;T\u0026gt; GetByIdAsync(int id); Task\u0026lt;T\u0026gt; AddAsync(T entity); Task UpdateAsync(T entity); Task DeleteAsync(T entity); } 下訂單Repository介面，Order來自Domian Layer的Entity\npublic interface IOrderRepository : IAsyncRepository\u0026lt;Order\u0026gt; { Task\u0026lt;IEnumerable\u0026lt;Order\u0026gt;\u0026gt; GetOrdersByUserName(string userName); } Infrastructure Email發送服務介面，Email class建立在Models/Email.cs\npublic interface IEmailService { Task\u0026lt;bool\u0026gt; SendEmail(Email email); }  Features  存放Use case，目前只有Orders一個Use case，並實作CQRS。\n建資料夾 Features/Orders/Commands Features/Orders/Queries\nQueries/GetOrderList 先處理Queries Features/Orders/Queries/GetOrdersList/GetOrdersListQuery.cs Features/Orders/Queries/GetOrdersList/GetOrdersListQueryHandler.cs Features/Orders/Queries/GetOrdersList/OrdersVm.cs\nGetOrdersListQuery IRequest介面來自於MediatR DI Version，裡面List\u0026lt;OrdersVm\u0026gt;代表要回傳的type\nusing MediatR; public class GetOrdersListQuery : IRequest\u0026lt;List\u0026lt;OrdersVm\u0026gt;\u0026gt; { public string UserName { get; set; } public GetOrdersListQuery(string userName) { UserName = userName ?? throw new ArgumentNullException(nameof(userName)); } } GetOrdersListQueryHandler 當Query被觸發時Handler會負責處理，實作IRequestHandler會得到Handle這個Function，並寫入我們要進行的操作\n//IRequestHandler\u0026lt;要處理的IRequest, 輸出的type\u0026gt; public class GetOrdersListQueryHandler : IRequestHandler\u0026lt;GetOrdersListQuery, List\u0026lt;OrdersVm\u0026gt;\u0026gt; { private readonly IOrderRepository _orderRepository; private readonly IMapper _mapper; //使用在Contract裡面寫的orderRepository  public GetOrdersListQueryHandler(IOrderRepository orderRepository, IMapper mapper) { _orderRepository = orderRepository; _mapper = mapper; } public async Task\u0026lt;List\u0026lt;OrdersVm\u0026gt;\u0026gt; Handle(GetOrdersListQuery request, CancellationToken cancellationToken) { var orderList = await _orderRepository.GetOrdersByUserName(request.UserName); return _mapper.Map\u0026lt;List\u0026lt;OrdersVm\u0026gt;\u0026gt;(orderList); } } OrdersVm 可以看到這個class是放在Queries/GetOrdersList裡面，只給GetOrdersList這個Use Case用，與Entity層的Order.cs無關，雖然他們長得一樣。\npublic class OrdersVm { public int Id { get; set; } public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } } Commands/CheckoutOrder 接下來要處理Command的部分\n先處理CheckoutOrder\n//Features/Orders/Commands/CheckoutOrder/CheckoutOrderCommand.cs //回傳int訂單編號 public class CheckoutOrderCommand : IRequest\u0026lt;int\u0026gt; { public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } } 一樣使用MediatR的功能，透過handler來處理\n//Features/Orders/Commands/CheckoutOrder/CheckoutOrderCommandHandler.cs public class CheckoutOrderCommandHandler : IRequestHandler\u0026lt;CheckoutOrderCommand, int\u0026gt; { private readonly IOrderRepository _orderRepository; private readonly IMapper _mapper; //Application層下的mappings  private readonly IEmailService _emailService;//Application層下的contracts/infastucture  private readonly ILogger\u0026lt;CheckoutOrderCommandHandler\u0026gt; _logger; //依賴注入需要的元件  public CheckoutOrderCommandHandler(IOrderRepository orderRepository, IMapper mapper, IEmailService emailService, ILogger\u0026lt;CheckoutOrderCommandHandler\u0026gt; logger) { _orderRepository = orderRepository ?? throw new ArgumentNullException(nameof(orderRepository)); _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper)); _emailService = emailService ?? throw new ArgumentNullException(nameof(emailService)); _logger = logger ?? throw new ArgumentNullException(nameof(logger)); } //實作IRequestHandler  public async Task\u0026lt;int\u0026gt; Handle(CheckoutOrderCommand request, CancellationToken cancellationToken) { var orderEntity = _mapper.Map\u0026lt;Order\u0026gt;(request); var newOrder = await _orderRepository.AddAsync(orderEntity); _logger.LogInformation($\u0026#34;訂單{newOrder.Id}建立成功\u0026#34;); await SendMail(newOrder); return newOrder.Id; } private async Task SendMail(Order order) { var email = new Email() { To = \u0026#34;test@gmail.com\u0026#34;, Body = $\u0026#34;Order was created.\u0026#34;, Subject = \u0026#34;Order was created\u0026#34; }; try { await _emailService.SendEmail(email); } catch (Exception ex) { _logger.LogError($\u0026#34;訂單{order.Id}發生錯誤，mail service: {ex.Message}\u0026#34;); } } } 最後會加上一個驗證，在Behaviors那邊加入。\nusing FluentValidation;//使用驗證套件 public class CheckoutOrderCommandValidator : AbstractValidator\u0026lt;CheckoutOrderCommand\u0026gt; { public CheckoutOrderCommandValidator() { //p代表property  RuleFor(p =\u0026gt; p.UserName)//驗證UserName  .NotEmpty().WithMessage(\u0026#34;UserName 必填\u0026#34;)//不可為空值，若為空值回傳訊息  .NotNull() .MaximumLength(50).WithMessage(\u0026#34;UserName 字數過長\u0026#34;); RuleFor(p =\u0026gt; p.EmailAddress) .NotEmpty().WithMessage(\u0026#34;EmailAddress 必填\u0026#34;); RuleFor(p =\u0026gt; p.TotalPrice) .NotEmpty().WithMessage(\u0026#34;TotalPrice 必填\u0026#34;) .GreaterThan(0).WithMessage(\u0026#34;TotalPrice 需要大於0\u0026#34;); } } Commands/DeleteOrder UpdateOrder、DeleteOrder基本與CheckoutOrder類似，不過有幾個地方不太一樣。\nCommand只需要IRequest，不需用泛型。\npublic class DeleteOrderCommand : IRequest { public int Id { get; set; } } 如果Command本身沒有要回傳值的話，就回傳Unit.Value給MediatR知道\npublic async Task\u0026lt;Unit\u0026gt; Handle(DeleteOrderCommand request, CancellationToken cancellationToken) { var orderToDelete = await _orderRepository.GetByIdAsync(request.Id); if(orderToDelete == null) { throw new Exception($\u0026#34;找不到訂單{request.Id}\u0026#34;); } await _orderRepository.DeleteAsync(orderToDelete); _logger.LogInformation($\u0026#34;訂單{request.Id}刪除完成\u0026#34;); return Unit.Value;//如果Command本身沒有要回傳值的話，就回傳Unit.Value給MediatR知道 }  Behaviors  我們會在Handler前後進行驗證User使用的行為(輸入)是否正常\n整個流程大概如下\nCaller \u0026raquo; Request \u0026raquo; 前處理 \u0026raquo; Handler \u0026raquo; 後處理\n//實作MediatR提供的IPipelineBehavior來註冊前、後處理 public class ValidationBehaviour\u0026lt;TRequest, TResponse\u0026gt; : IPipelineBehavior\u0026lt;TRequest, TResponse\u0026gt; { //這將會讀取所有Validator，只要有繼承AbstractValidator\u0026lt;TRequest\u0026gt;(來自FluentValidation)  private readonly IEnumerable\u0026lt;IValidator\u0026lt;TRequest\u0026gt;\u0026gt; _validators; public ValidationBehaviour(IEnumerable\u0026lt;IValidator\u0026lt;TRequest\u0026gt;\u0026gt; validators) { _validators = validators; } public async Task\u0026lt;TResponse\u0026gt; Handle(TRequest request, CancellationToken cancellationToken, RequestHandlerDelegate\u0026lt;TResponse\u0026gt; next) { if (_validators.Any())//如果有Validator的話  { //驗證輸入  var context = new ValidationContext\u0026lt;TRequest\u0026gt;(request); //等待所有非同步執行結果 ( 對所有驗證項目進行非同步工作 )  var validationResults = await Task.WhenAll(_validators.Select(v =\u0026gt; v.ValidateAsync(context, cancellationToken))); //查看結果  var failures = validationResults.SelectMany(r =\u0026gt; r.Errors).Where(f =\u0026gt; f != null).ToList(); //如果有錯的話  if (failures.Count != 0) { throw new ValidationException(failures); } } //前處理的部份到此結束  var response = await next();//Handler處理完回傳  //後處理的部分從此開始  return response; } }  DI Service Collection  因為使用的服務有點多，把他們集中管理成一個Service Collection，之後直接註冊這個Collection就好了。\npublic static class ApplicationServiceRegistration { public static IServiceCollection AddApplicationServices(this IServiceCollection services) { services.AddAutoMapper(Assembly.GetExecutingAssembly()); services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly()); services.AddMediatR(Assembly.GetExecutingAssembly()); services.AddTransient(typeof(IPipelineBehavior\u0026lt;,\u0026gt;), typeof(UnhandledExceptionBehaviour\u0026lt;,\u0026gt;)); services.AddTransient(typeof(IPipelineBehavior\u0026lt;,\u0026gt;), typeof(ValidationBehaviour\u0026lt;,\u0026gt;)); return services; } } 到這邊Application Layer就到一段落了，實在很多很長，主要實作了CQRS與學習MediatR的操作，也更看清楚整個簡潔架構的設計。\n","date":"2021-12-17T11:44:52+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211217_%E7%B0%A1%E6%BD%94%E6%9E%B6%E6%A7%8Bapplication.md/","title":"簡潔架構 Application Layer"},{"content":"FluentValidation  介紹  雖說在工作上能不用第三方套件就不用，但練習的時候想做什麼就做什麼吧，一切輕鬆、簡單最好了。可以考慮用看看。\n紀錄一下常用的功能\nusing FluentValidation;//使用套件 public class CheckoutOrderCommandValidator : AbstractValidator\u0026lt;CheckoutOrderCommand\u0026gt;//要驗證的class { public CheckoutOrderCommandValidator() { //p代表property  RuleFor(p =\u0026gt; p.UserName)//驗證UserName  .NotEmpty().WithMessage(\u0026#34;UserName 必填\u0026#34;)//不可為空值，若為空值回傳訊息  .NotNull() .MaximumLength(50).WithMessage(\u0026#34;UserName 字數過長\u0026#34;); RuleFor(p =\u0026gt; p.EmailAddress) .NotEmpty().WithMessage(\u0026#34;EmailAddress 必填\u0026#34;); RuleFor(p =\u0026gt; p.TotalPrice) .NotEmpty().WithMessage(\u0026#34;TotalPrice 必填\u0026#34;) .GreaterThan(0).WithMessage(\u0026#34;TotalPrice 需要大於0\u0026#34;); } } 雖說正則表達式、Data Annotation也可以做到，這個看起來還蠻易讀的。\n","date":"2021-12-16T14:50:26+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211216_fluentvalidation%E9%A9%97%E8%AD%89%E5%A5%97%E4%BB%B6.md/","title":"FluentValidation"},{"content":"更新從來就沒有好事情  案發原因  不知道有多久沒有更新我的Line了，也沒有什麼值得我更新的功能，這樣穩穩著用就挺好的，早上收到Line錢包提醒我必須在12/31號前更新到最新版，平常出門已經很習慣Pay來Pay去了，得很方便，所以只能更新了。\nBOOM!\n更新完後Line直接閃退，再也打不開了，卸載重裝、重新開機都試過了，更新iOS到最新版本還是打不開，只好寫email給客服來處理，來回處理了兩天左右，客服發送消息給我說他們修正了問題，請至App Store更新最新版，這次更新完後終於可以登入了，還是要給他們的工程師點讚，這個效率算很快了。\nBOOM!ANGIN!\n原以為事情到這裡就告一個段落了，沒想到更新後導致的問題一一浮現，平常在使用的iPad 3居然連不到我手機的熱點了，一查才發現iOS 15加強了wifi存取保護(Wi-Fi Protected Access)，從wpa2升級到wpa3，導致不支援wpa3的設備將無法連接，而我的iPad 3就這樣再也連不上網路了。更慘的是網路上查了一輪，還是沒找到解決方法。\n只能祈求之後會開放可以改wpa2的選項，雖然我覺得很難。._.\n","date":"2021-12-16T13:10:12+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211216_%E6%9B%B4%E6%96%B0%E5%BE%9E%E4%BE%86%E5%B0%B1%E6%B2%92%E6%9C%89%E5%A5%BD%E4%BA%8B.md/","title":"更新從來就沒有好事情"},{"content":"正則表達式筆記  筆記  工作上剛好遇到一個需求，要過濾用戶輸入的英文ID\n 判斷規則\n 格式限定半形大寫英文 符號只能輸入.、-、/、\\還有空白 長度最長為50字元 至少有三個英文字，不可只有符號   原本打算先判斷輸入的正確的英文與符號且長度為3~50，在判斷英文字至少三個。\nusing System.Text.RegularExpressions; string EnglishName = \u0026#34;TEST-123\u0026#34;//user input Regex.IsMatch(EnglishName, \u0026#34;@^[A-Z//.\\\\\\s]{3,50}$\u0026#34;); Regex.IsMatch(EnglishName, \u0026#34;@^[A-Z{3,}$\u0026#34;); 使用預查來處理這個問題\n  正向肯定預查 (?=pattern) 表示從當前位置開始，預測後面的文字必須匹配上pattern 正向否定預查 (?!pattern) 表示從當前位置開始，預測後面的文字必須匹配不上pattern 反向肯定預查 (?\u0026lt;=pattern) 表示從當前位置開始，預測前面的文字必須匹配上pattern 反向否定預查 (?\u0026lt;!pattern) 表示從當前位置開始，預測前面的文字必須匹配不上pattern   有三個英文字後，才會判斷是否為長度3~50且正確的英文與符號。\nRegex.IsMatch(EnglishName, \u0026#34;@^(?=.*[A-Z].*[A-Z].*[A-Z])[A-Z//.\\\\\\s]{3,50}$\u0026#34;); 每次要寫RE都要查一下怎麼寫XD，希望我下次不要再忘記啦。\n參考 https://www.runoob.com/regexp/regexp-syntax.html https://blog.csdn.net/NAPO687/article/details/110198206\n","date":"2021-12-14T13:08:10+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211214_%E6%AD%A3%E5%89%87%E8%A1%A8%E9%81%94%E5%BC%8F.md/","title":"正則表達式筆記"},{"content":"XBOX Game Pass Ultimate  介紹  自小時候我就是Halo(最後一戰)系列的鐵桿粉絲了，在最初代XBOX上面不知道重破了好幾遍，這款遊戲也是我唯一想要購買XBOX的理由了，過了超久到了現在，Halo也不再是XBOX獨佔了(除了Halo 5)，其他版本皆已經能在PC上遊玩，如今Halo Infinite也正式推出，這次鐵了心買了XGPU的會員，一次就給他包3年。這三年微軟自家的遊戲都可以直接玩爆，還有EA PLAY可以玩，絕對玩不完的。 \r趕回來結束戰鬥\r\n 省錢  網路上有很多教你怎麼儲XGPU最劃算，但是算一算都還是要幾千元，因為台灣的XGPU價格太高了，國外其他地區的價格可能比台灣便宜上不少，所以自行跨區購買或是請人代儲可能是最划算的方案，但是這些風險都比較高，但是我打開淘寶看到代儲3年只要118人民幣，真的是太香了，直接秒速下訂，但發現淘寶的虛擬物品只能透過中國的銀行卡來進行付款，不支持海外刷卡，或是玉山ATM轉帳，只能去蝦皮找代付，看了幾家都差不多錢，公道價應該是1:5.4台幣，換算下來淘寶代儲只需要台幣637，一年只要200出頭，太划算了。\n 代儲  代儲最好使用小號且要先把密碼隨便改掉，再給淘寶的店家比較安全，店家登入時會再跟你要登入安全碼，我不確定店家是如何把成本壓那麼低的，不過代儲時會看到自己的信箱收到來自微軟的日文信件的付款訊息，應該官方的沒錯，最後記得把密碼改掉。 \r代儲時收到的日文信件\r\n","date":"2021-12-13T17:25:11+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211211_xboxgamepass.md/","title":"XBOX Game Pass Ultimate"},{"content":"刀劍神域 無星夜的詠嘆調 劇場版  心得(小雷)  沒想到刀劍神域又出劇場版了，我好興奮啊!!上一次看序列爭戰我還在高雄念書，特別跑去市區超遠的高雄大遠百看4dx，那次也是我第一次體驗4dx的威力，那個動態座椅讓我完全融入在畫面裡面，刀刀砍在背上的感覺，刀削的氣流在耳邊噴發，我現在還在激動啊！總之就是回不去了，當時學生票好像是450還500有點忘記了，這個價錢對於學生的我也是不小的金額，但我還是覺得超值得。\n這次去看的電影院是信義威秀，看了一下票價原價要550，這個票價也不是鬧著玩的，身為半個客家人的我，發現蝦皮上面有在賣威秀的招待票一張300元，而且可以看4dx，立馬下定，相見恨晚，太划算了。\n\r用招待票通常是不能拿特典的，但是店員還是發給我，小確幸XD。\r\n刀劍神域Progressive是以亞絲娜作為故事主角出發，講述了進入SAO的原因及第一層的故事，本傳後面出了一堆遊戲但還是沒有比SAO更刺激好看，這個冷飯，真香。劇情還是有做一些修改與本傳不同，多了米特這個角色，她與亞絲娜從最好的朋友，遇到死結時選擇退出隊伍自己離開，到最後互相體諒和好，並走上各自的道路，完美呼應主題曲『前行』的歌詞。\n中間一定要加上桐老爺出來裝逼，帥氣收割一波，整體畫面跟音樂我都很滿意，再加上動態座椅的加持，滿分10分我給9.5分，要是能有60FPS那就完美了，2022年也要出另一部劇場版，沒意外也要看4dx!\n","date":"2021-12-09T13:29:52+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211207_%E5%88%80%E5%8A%8D%E7%A5%9E%E5%9F%9Fprogressive.md/","title":"刀劍神域Progressive 無星夜的詠嘆調 劇場版"},{"content":"指數投資  前情提要  在過去學生時期的時候就接觸了股票，總覺得要錢滾錢才能財富自由，把打工的錢都拿去玩看看，當時的選股策略是\n1.股價夠低(因為本金太小買不起太貴的股票，每一次買股票都是All in)\n2.看起來現在在低檔，低到不能再低的感覺\n當時All in買了陽明4塊多還5塊，沒過幾天不知怎麼就噴到漲停，抓到一個低買高賣的節奏，沒多久就把它出清了，獲利4000$多，後來又聽朋友建議去買光學鏡頭股玉晶光，也賺了好幾千，我該不會其實很適合玩股票吧XD，直到我膝蓋中了一箭，南亞科賠20000元，沒想到那麼慘，之後就退出股海了。\n直到現在全球股市一直突破新高，並且出社會領薪水的時候，我，再次回歸！等等這不會是高點的訊號吧QQ\n對了，這邊不做任何投資建議喔，單純心得分享。\n 啟蒙  領了薪水後，只能說錢真的賺，現在年輕人基本上沒什麼希望，光活著就已經費盡全力，每週40小時的生命賣給公司，扣掉基本開銷、房租、伙食，可以花的錢也就一萬多吧，還沒有任何娛樂，活著，卻像是個死人，但想到父母為了我也把自己的生命販賣給公司，只為了能讓我有好的生活，我又有什麼好藉口不去努力呢？\n看了一本關於理財的書籍『我用死薪水輕鬆理財賺千萬』，讓我了解的資產配置、再平衡與指數投資的基本概念，書中的內容都淺顯易懂，沒有什麼難以離解的東西。之後也看了網路上許多的文章與影片，清流君、魯爸、yp筆記、多拉王與伯格頭投資指南，都讓我堅信指數投資是個GOOD SHIT~\n 伯格頭的投資指南\n evelop a workable plan Invest early and ofter Never bear too much or too little risk Diversify Never try to time the market Use index funds when possible Keep costs low Minimize taxes Invest with simplicity Stay the course    開戶準備  伯格頭的投資指南第7條，Keep costs low，盡可能地減少投資成本。\n成本最低的應該是台股定期定額(新光證券20000內，手續費1元)\n海外複委託美股(富邦證券，0.12%，低消12美金)\n海外複委託英股(富邦證券，0.15%，低消15美金)\n海外券商(電匯費用一次800吧(不確定沒用過)，交易手續費趨近於0)\n金額大的話海外券商比複委託還要省很多，不過我自己錢還沒有那麼多，現在階段用復委託會比較便宜一點。\n 投資標的  伯格頭的投資指南第4條，Diversify，多樣性。\nETF一籃子的股票，含有各個領域與不同公司的股票\n伯格頭的投資指南第6條，Use index funds when possible，如果可能的話使用指數基金。\n006208 可以把它想成內扣費用較低的0050\n伯格頭的投資指南第8條，Minimize taxes，上班族繳太多稅了，少繳一點。\nVWRD 可以把它想成英國版的VT，但少了小型股部位，稅也比較少了。\n 投資組合  伯格頭的投資指南第9條，Invest with simplicity，簡單才好管理。\n由於使用復委託，標的太多交易成本會太高，所以我是沒有配債的部位，先用高利率活存來代替，未來在考慮要不要加入債券部位。\n股票部位：VWRD 80%、006208 20%\n 投入時間  伯格頭的投資指南第5條，Never try to time the market，錢夠就丟，我就看他能不能長出一朵花。\n持有越久的現金機會成本越大，應該儘早投入。\nVWRD每3~4個月手動操作買入\n006208定期定額買入\n 未來  薪水高，累積財富的速度也才會快，專注於本業，提升自己的能力與價值。\n伯格頭的投資指南第10條，Stay the course，持之以恆。\n一直堅持下去就對了，如果心中有所疑惑，那可能是投資組合不適合自己，要再做調整。\n\r\n","date":"2021-12-06T10:55:10+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211206_%E6%8C%87%E6%95%B8%E6%8A%95%E8%B3%87.md/","title":"指數投資"},{"content":"Clean Architecture  介紹  接下來的筆記是根據線上課程Microservices Architecture and Implementation on .NET 5所記錄下來的，講者的口音有點重，聽得有點吃力，他這個專案基本上重做微軟提供的範例專案，電商系統，完美呈現微服務的使用與他的優點，一共把服務切成四個主要的服務，Catalog(商品目錄系統)、Basket(購物車系統)、Discount(折扣系統)、Ordering(訂單系統)，並分別使用不同的資料庫(mongodb、redis、PostgreSQL、MSSQL)、不同的傳輸協定(Rest API、Grpc)、不同的架構(多層式架構、簡潔架構)，最後使用Docker容器化，把他們都整合在一起運作。\n\r整個系統的架構圖\r\n工作一陣子了，維護的系統基本也都上手了(龐大的Web Service架構)，但還有許多前人的智慧，一時之間是很難理解的XD，這時有一個乾淨的架構，或許上手的時間就可以更短了。\n Domain Layer  建立一個訂單系統使用Clean Architecture\n依照分層創建各個不同的Project， Ordering.API Ordering.Domain Ordering.Application Ordering.infrastructure \r整個系統的架構圖\r\n建立相依關係Project右鍵 \u0026gt;\u0026gt; Add \u0026gt;\u0026gt; Reference \r相依關係\r\n詳細定義與設計可以參考\nhttps://ithelp.ithome.com.tw/articles/10223150 https://ithelp.ithome.com.tw/articles/10223595\n 開發Ordering.Domain Layer  我們要先建立兩個資料夾Common、Entities\nCommon 其中Common放的是我們建立Entity的基礎，含有兩個abstract class，EntityBase、ValueObject，\n//我們每一個Entity都要的屬性 public abstract class EntityBase { public int Id { get; protected set; } public string CreatedBy { get; set; } public DateTime CreatedDate { get; set; } public string LastModifiedBy { get; set; } public DateTime? LastModifiedDate { get; set; } } Entities 建立Order物件並繼承EntityBase\n//訂單必須要的屬性 public class Order : EntityBase { public string UserName { get; set; } public decimal TotalPrice { get; set; } // BillingAddress  public string FirstName { get; set; } public string LastName { get; set; } public string EmailAddress { get; set; } public string AddressLine { get; set; } public string Country { get; set; } public string State { get; set; } public string ZipCode { get; set; } // Payment  public string CardName { get; set; } public string CardNumber { get; set; } public string Expiration { get; set; } public string CVV { get; set; } public int PaymentMethod { get; set; } }  參考  https://www.udemy.com/course/microservices-architecture-and-implementation-on-dotnet/ https://rwang.medium.com/%E5%86%8D%E8%AE%80%E6%95%B4%E6%BD%94%E6%9E%B6%E6%A7%8B-clean-architecture-12b562472c3b\n","date":"2021-12-02T15:52:49+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021202_%E7%B0%A1%E6%BD%94%E6%9E%B6%E6%A7%8Bdomain.md/","title":"簡潔架構 Domain Layer"},{"content":"CQRS  筆記  CQRS(Command Query Responsibility Segregation)命令查詢分隔，目前看起來就是不再需要IRepository了，把它拆成Command(負責寫入資料庫的部分)與Query(只負責讀取的部分)。\n可以增加資料庫的效能，Command的部分則會透過event的形式記錄起來再同步到DB上面。\n我還是偏好原本的方法啊XD\n 參考  https://ithelp.ithome.com.tw/articles/10237458\n","date":"2021-12-01T11:08:44+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021201_cqrs.md/","title":"CQRS"},{"content":"Domain Driven Design  關於DDD  隨著科技進步，需求也是越來越複雜，更多的是需要專業領域人員與開發人員共同協作\nDDD是一種基於領域知識來解決複雜業務問題的軟體開發方法論。\n Ubiquitous Language  使用通用語言就很重要了，講人話，減少溝通成本。 ex:下訂單大家就聽得懂，別講些什麼call Order API、B2C之類的\n Anemic Model  Anemic Model貧血模型是指那些只有getter、setter沒有行為能力的模型\nLF2邪鬼(地獄火焰)防下功+防上跳+防前跳+防下跳+防上功 為例\nDevil Max = new Devil(); //使用地獄火焰 Max.Defence().Down().Attack(); Max.Defence().Up().Jump(); Max.Defence().Left().Jump(); Max.Defence().Down().Jump(); Max.Defence().Up().Attack(); 導入DDD與專家討論過後，未來開發的人員直接看程式碼也看得懂在幹嘛\nDevil Max = new Devil(); Max.HellFire();  與微服務的關係  很多時候Micorservices不知道怎麼做切割，這時候DDD就提供一個很好的方向去做業務分割。\n 參考  https://ithelp.ithome.com.tw/articles/10216645 https://forum.gamer.com.tw/C.php?bsn=7648\u0026snA=3299\n","date":"2021-11-30T14:30:40+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021130_ddd.md/","title":"Domain Driven Design 領域驅動設計"},{"content":"SOLID、SoC  SOLID原則  Single responsibility principle 單一功能原則 認為一個class就應該只有一個任務要做，不做其他任務以外的事情，過去是很多不同的需求都用同一個Service，單一功能原則則是提供各種不同的Use Case給各個需求。 \rSRP示意圖\r\nOpen/ closed principle 開閉原則 一個class或Function對於他的擴展是開放的，但是對於修改是封閉的，意思就是不改變他的行為，但是可以增加新的功能。 就像是電動理髮刀，可以換上各種不同的刀頭(擴展)，但是機身本體是不能修改的(封閉)。\nLiskov substitution principle 里氏替換原則 程式中的物件應該是可以在不改變正確性的前提下被他的子類所替換的概念，我們在使用「繼承」時，重要的是重複使用 (reuse) 已經寫好的行為，而不是將所有繼承的行為全部覆蓋。\nInterface segregation principle 介面隔離原則 很多個客製化的interface比一個通用的interface還要來得更好管理，例如一個政客interface有提出政見()、拜票()、努力工作()，但事實上不是每一個政客都想實作努力工作XD，所以應該方別建兩個interface，政客介面:提出政見()、拜票()與工作介面:努力工作()。\nDependency inversion principle 依賴反轉原則 各個class之間的相依性應該越低越好，上層的class不該依賴下層的class \rDIP示意圖\r\n SoC(Separation of concerns) 關注點分離  關注點分離表示，以前端的例子來說，在過去我們是以「關注技術」的方式來分離成HTML、CSS、JavaScript，現今主流框架Vue則是採用「關注元件」的方式來分離，每一個Component都有各自的HTML、CSS、JavaScript。\n 參考  https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1) https://medium.com/@f40507777/%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87-open-closed-principle-31d61f9d37a5 https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/%E7%AC%AC-10-%E7%AB%A0-%E9%A1%9E%E5%88%A5-clean-code-1c7898d11cd7\n","date":"2021-11-29T16:10:40+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021129_solid%E5%8E%9F%E5%89%87.md/","title":"SOLID、SoC"},{"content":"使用Grpc服務  前情提要  購物車的功能需要導入折價券.Grpc的服務\n購物車是Client端\n折價券是Server端\n 新增Grpc服務的reference  VS for Mac在專案下面就可以直接看到Connected Services Windows則是右鍵 \u0026raquo; Add \u0026raquo; connected services\n選取購物車專案的connected services \u0026raquo; Add new Grpc service reference \u0026raquo; Add \u0026raquo; 參照折價券.Grpc裡面的.proto \u0026raquo; 選擇Client模式\n執行完後，可以看到.csproj多了Grpc服務、專案下也多了protos\n\u0026lt;Protobuf Include=\u0026#34;..\\..\\Discount\\Discount.Grpc\\Discount.Grpc\\Protos\\discount.proto\u0026#34; GrpcServices=\u0026#34;Client\u0026#34;\u0026gt; \u0026lt;OutputDir\u0026gt;obj\\Debug\\net5.0\\\u0026lt;/OutputDir\u0026gt; \u0026lt;Link\u0026gt;Protos\\discount.proto\u0026lt;/Link\u0026gt; \u0026lt;/Protobuf\u0026gt; 建置專案後，也會產生ProtoServiceClient等cs檔\n 參考  https://pjchender.dev/golang/grpc-getting-started/ https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-6.0\u0026tabs=visual-studio\n","date":"2021-11-25T15:57:43+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/2021125_%E4%BD%BF%E7%94%A8grpc%E6%9C%8D%E5%8B%99.md/","title":"使用Grpc服務"},{"content":"AutoMapper 筆記  簡單介紹  可以輕鬆的轉換兩個class，讓程式碼變得更加簡短乾淨。\n 範例  message CouponModel { int32 id = 1; string productName = 2; string description = 3; int32 amount = 4; } 在Grpc定義的優戶券模型\npublic class Coupon { public int Id { get; set; } public string ProductName { get; set; } public string Description { get; set; } public int Amount { get; set; } } 我們自己定義的模型\n原先轉換需要像是這個樣子\nCoupon coupon; CouponModel cm = new CouponModel{ id = coupon.Id, productName = coupon.ProductName, description = coupon.Description, amount = coupon.Amount } 使用Mapper後只要\nCoupon coupon; CouponModel cm = _mapper.Map\u0026lt;CouponModel\u0026gt;(coupon);  如何使用  1.Nuget搜尋並下載AutoMapper.Extensions.Microsoft.DependencyInjection\n2.在Startup註冊AutoMapper服務\npublic void ConfigureServices(IServiceCollection services) { services.AddAutoMapper(typeof(Startup)); } 3.建立轉換的Porfile\npublic class CouponProfile :Profile //繼承Profile { public CouponProfile() { //讓Coupon與CouponModel可以方便地互相轉換  CreateMap\u0026lt;Coupon, CouponModel\u0026gt;().ReverseMap(); } } 4.依賴注入到需要使用的class裡\nprivate readonly IMapper _mapper; public DiscountService(IIMapper mapper) { _mapper = mapper; } 5.享受AutoMapper帶來的便利~~\n 參考  https://igouist.github.io/post/2020/07/automapper/\n","date":"2021-11-25T14:55:07+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211125_automapper.md/","title":"AutoMapper - DI Version"},{"content":"Grpc 筆記  簡單介紹  Grpc是google開發的rpc(Remote Procedure Call)框架，用於電腦與電腦之間的溝通，就像電腦A呼叫電腦B做事情，電腦B做好事情後把結果回傳給電腦A，與一般的api不同的地方在於，電腦A、B在進行Grpc溝通前，都必須有protocal buffers檔案來把格式與方法定義清楚，並使用HTTP/2進行傳輸，快速、低延遲、支持串流。\n protocal buffers 檔案  syntax = \u0026#34;proto3\u0026#34;;//使用的protocal buffers版本  option csharp_namespace = \u0026#34;MyFirstGrpc.Grpc\u0026#34;;//命名空間  package greeter; // 定義交換資料的格式 message HelloRequest { string name = 1; } // 定義交換資料的格式 message HelloReply { string message = 1; } // 定義呼叫api的方法 service Greeter { // SayHello方法需要輸入參數(HelloRequest格式) 會回傳(HelloReply格式)  rpc SayHello (HelloRequest) returns (HelloReply); }  AppSettings 使用Http2  { \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft\u0026#34;: \u0026#34;Warning\u0026#34;, \u0026#34;Microsoft.Hosting.Lifetime\u0026#34;: \u0026#34;Information\u0026#34; } }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Kestrel\u0026#34;: { \u0026#34;EndpointDefaults\u0026#34;: { \u0026#34;Protocols\u0026#34;: \u0026#34;Http2\u0026#34; } } } 我們可以看到在AppSettings裡Protocols是採用Http2\n 產生Service class檔案  如果設定都沒有錯的話，會在MyFirstGrpc.Grpc/obj/Debug/net5.0/Protos產生Greet.cs與GreetGrpc.cs\n若資料夾內沒有產生cs檔，很有可能是專案檔MyFirstGrpc.Grpc.csproj裡面設定有問題。\n確保有\u0026lt;Protobuf Include=\u0026quot;Protos\\greet.proto\u0026quot; GrpcServices=\u0026quot;Server\u0026quot; /\u0026gt;對.proto做編譯\n//參考的.csproj \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Project Sdk=\u0026#34;Microsoft.NET.Sdk.Web\u0026#34;\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;None Remove=\u0026#34;Protos\\greeter.proto\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Grpc.AspNetCore\u0026#34; Version=\u0026#34;2.32.0\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;Protobuf Include=\u0026#34;Protos\\greeter.proto\u0026#34; GrpcServices=\u0026#34;Server\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;/Project\u0026gt;  GreeterService 實作  namespace MyFirstGrpc.Grpc { public class GreeterService : Greeter.GreeterBase { private readonly ILogger\u0026lt;GreeterService\u0026gt; _logger; public GreeterService(ILogger\u0026lt;GreeterService\u0026gt; logger) { _logger = logger; } public override Task\u0026lt;HelloReply\u0026gt; SayHello(HelloRequest request, ServerCallContext context) { return Task.FromResult(new HelloReply { Message = $\u0026#34;Hello {request.Name}\u0026#34; }); } } } 在Services/GreeterService.cs下\n繼承自動產生的Greeter下的GreeterBase並將其覆寫，最主要的邏輯也是寫在這邊。\nSayHello方法需要輸入參數(HelloRequest格式) 會回傳(HelloReply格式)\nTip:輸入override按下空白，VS會自動把可以override的class顯示出來。\n 註冊Grpc服務  public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddGrpc(); } public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseRouting(); app.UseEndpoints(endpoints =\u0026gt; { endpoints.MapGrpcService\u0026lt;GreeterService\u0026gt;(); endpoints.MapGet(\u0026#34;/\u0026#34;, async context =\u0026gt; { await context.Response.WriteAsync(\u0026#34;Communication with gRPC endpoints must be made through a gRPC client. To learn how to create a client, visit: https://go.microsoft.com/fwlink/?linkid=2086909\u0026#34;); }); }); } } 在startup.cs下 透過services.AddGrpc();註冊Grpc服務，方可使用Grpc。 透過endpoints.MapGrpcService\u0026lt;GreeterService\u0026gt;();把所有Grpc服務部署到Routing Pipeline裡\n 參考  https://pjchender.dev/golang/grpc-getting-started/ https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-6.0\u0026tabs=visual-studio\n","date":"2021-11-24T10:12:35+08:00","permalink":"https://mindbreaker3310.github.io/posts/post/20211124_grpcmemo.md/","title":"Grpc 筆記"}]