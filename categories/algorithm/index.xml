<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on MindBreaker3310</title>
    <link>https://mindbreaker3310.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on MindBreaker3310</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Oct 2021 20:11:06 +0800</lastBuildDate><atom:link href="https://mindbreaker3310.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rotate Array</title>
      <link>https://mindbreaker3310.github.io/posts/rotate-array/</link>
      <pubDate>Tue, 19 Oct 2021 20:11:06 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/rotate-array/</guid>
      <description>189. Rotate Array  題目  ‎給一個陣列，將陣列向右旋轉k步。
 範例  Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  解答  public class Solution { public void Rotate(int[] nums, int k) { if (nums.</description>
    </item>
    
    <item>
      <title>Squares of a Sorted Array</title>
      <link>https://mindbreaker3310.github.io/posts/squares-of-a-sorted-array/</link>
      <pubDate>Tue, 19 Oct 2021 20:07:04 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/squares-of-a-sorted-array/</guid>
      <description>977. Squares of a Sorted Array  題目  給一個由排序到大的陣列，回傳每個數值都平方的排序陣列。
 範例  Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121]  解答  public class Solution { public int[] SortedSquares(int[] nums) { int[] ans = new int[nums.Length]; int i = 0; int j = nums.Length - 1; int p = j; while (i &amp;lt;= j) { if (Math.</description>
    </item>
    
    <item>
      <title>First Bad Version</title>
      <link>https://mindbreaker3310.github.io/posts/first-bad-version/</link>
      <pubDate>Tue, 19 Oct 2021 13:26:30 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/first-bad-version/</guid>
      <description>278. First Bad Version  題目  ‎給一個整數陣列，找到&amp;quot;連續&amp;quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。
 範例  Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -&amp;gt; false call isBadVersion(5) -&amp;gt; true call isBadVersion(4) -&amp;gt; true Then 4 is the first bad version. Input: n = 1, bad = 1 Output: 1  解答  public class Solution : VersionControl { public int FirstBadVersion(int n) { for (int i = n; i &amp;gt;= 1; i--) { if (!</description>
    </item>
    
    <item>
      <title>Search Insert Pposition</title>
      <link>https://mindbreaker3310.github.io/posts/search-insert-position/</link>
      <pubDate>Mon, 18 Oct 2021 22:16:12 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/search-insert-position/</guid>
      <description>35. Search Insert Position  題目  ‎給一個整數陣列，找到&amp;quot;連續&amp;quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。
 範例  Input: nums = [1,3,5,6], target = 5 Output: 2 Input: nums = [1,3,5,6], target = 2 Output: 1  解答  public class Solution { public int SearchInsert(int[] nums, int target) { int low = 0; int high = nums.Length - 1; while (low &amp;lt;= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &amp;lt; target) { low = mid + 1; } else if (nums[mid] &amp;gt; target) { high = mid - 1; } } return low; } }  筆記  基本上與Binary Search的用法沒有區別，只差在return low的原因是當low &amp;lt;= high時，low的位置剛好會在target應該要在的位置上。</description>
    </item>
    
    <item>
      <title>Binary search algorithm</title>
      <link>https://mindbreaker3310.github.io/posts/binary-serarch/</link>
      <pubDate>Mon, 18 Oct 2021 20:10:11 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/binary-serarch/</guid>
      <description>704. Binary Search  題目  給一個由小到大排序的整數陣列nums與一個目標整數target，如果target存在於nums之中，回傳該目標數的index，否則回傳-1。
時間複雜度必須為O(log n)。
 範例  Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1  解答  public class Solution { public int Search(int[] nums, int target) { int low = 0; int high = nums.</description>
    </item>
    
  </channel>
</rss>
