<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on MindBreaker3310</title>
    <link>https://mindbreaker3310.github.io/categories/leetcode/</link>
    <description>Recent content in LeetCode on MindBreaker3310</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Oct 2021 20:46:32 +0800</lastBuildDate><atom:link href="https://mindbreaker3310.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reverse Words in a String III</title>
      <link>https://mindbreaker3310.github.io/posts/reverse-words-in-a-string-iii/</link>
      <pubDate>Thu, 21 Oct 2021 20:46:32 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/reverse-words-in-a-string-iii/</guid>
      <description>557. Reverse Words in a String III  題目  只反轉句子裡面的單字，而不改變單字的順序。
 範例  Input: s = &amp;#34;Let&amp;#39;s take LeetCode contest&amp;#34; Output: &amp;#34;s&amp;#39;teL ekat edoCteeL tsetnoc&amp;#34; Input: s = &amp;#34;God Ding&amp;#34; Output: &amp;#34;doG gniD&amp;#34;  解答  public class Solution { public string ReverseWords(string s) { string[] subs = s.Split(&amp;#34; &amp;#34;); for (int i = 0; i &amp;lt; subs.Length; i++) { subs[i] = new string(subs[i].Reverse().ToArray()); } return String.Join(&amp;#34; &amp;#34;, subs); } }  解題思路  先將句子切割成一個個單字的矩陣，再分別把每個單字做轉換，最後再合併成一個字串。</description>
    </item>
    
    <item>
      <title>Reverse String</title>
      <link>https://mindbreaker3310.github.io/posts/reverse-string/</link>
      <pubDate>Thu, 21 Oct 2021 20:45:46 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/reverse-string/</guid>
      <description>344. Reverse String  題目  反轉這個char[]，而不能使用其他記憶體空間。
 範例  Input: s = [&amp;#34;h&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;o&amp;#34;] Output: [&amp;#34;o&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;l&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;h&amp;#34;] Input: s = [&amp;#34;H&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;h&amp;#34;] Output: [&amp;#34;h&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;n&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;H&amp;#34;]  解答  public class Solution { public void ReverseString(char[] s) { for (int i = 0; i &amp;lt; s.Length/2; i++) { char temp = s[i]; s[i] = s[s.Length - 1 - i]; s[s.Length - 1 - i] = temp; } } }  解題思路  就轉&amp;hellip;
 參考  https://leetcode.</description>
    </item>
    
    <item>
      <title>Pascal&#39;s Triangle</title>
      <link>https://mindbreaker3310.github.io/posts/rascals-triangle/</link>
      <pubDate>Thu, 21 Oct 2021 20:45:17 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/rascals-triangle/</guid>
      <description>118. Pascal&amp;rsquo;s Triangle  題目  給要得行數，建立出Pascal三角形的陣列。
Pascal’s Triangle
 範例  Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Input: numRows = 1 Output: [[1]]  解答  public class Solution { public IList&amp;lt;IList&amp;lt;int&amp;gt;&amp;gt; Generate(int numRows) { //建立二維陣列  int[][] ans = new int[numRows][]; for (int i = 0; i &amp;lt; numRows; i++) { ans[i] = new int[i + 1]; } for (int n = 0; n &amp;lt; numRows; n++) { for (int i = 0; i &amp;lt; ans[n].</description>
    </item>
    
    <item>
      <title>Reshape the Matrix</title>
      <link>https://mindbreaker3310.github.io/posts/reshape-the-matrix/</link>
      <pubDate>Thu, 21 Oct 2021 20:44:35 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/reshape-the-matrix/</guid>
      <description>566. Reshape the Matrix  題目  實作在Matlab非常好用的功能reshape，他可以將matrix變形。
給一個二維matrix，將其換成r*c 的matrix。
若不能轉換，則回傳原matrix。
 範例  範例1
Input: mat = [[1,2],[3,4]], r = 1, c = 4 Output: [[1,2,3,4]] 範例2
Input: mat = [[1,2],[3,4]], r = 2, c = 4 Output: [[1,2],[3,4]]  解答  { public int[][] MatrixReshape(int[][] mat, int r, int c) { int matRows = mat.Length; int matColumns = mat[0].Length; if (matRows * matColumns != r * c) { return mat; } //C#建立多維矩陣的方法 int[][] ans = new int[r][]; for (int i = 0; i &amp;lt; r; i++) { ans[i] = new int[c]; } int x = 0; int y = 0; for (int i = 0; i &amp;lt; r; i++) { for (int j = 0; j &amp;lt; c; j++) { if (y == matColumns) { x++; y = 0; } ans[i][j] = mat[x][y]; y++; } } return ans; } }  解題思路  方法有很多種，這算是最直覺的方式了，先建立要輸出的matrix，再由左至右(i)、由上至下(j)一個一個填入，而填入的數值也是如此移動(x, y)，遇到y == matColumns就換行。</description>
    </item>
    
    <item>
      <title>Best Time to Buy and Sell Stock</title>
      <link>https://mindbreaker3310.github.io/posts/best-time-to-buy-and-sell-stock/</link>
      <pubDate>Wed, 20 Oct 2021 20:36:55 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/best-time-to-buy-and-sell-stock/</guid>
      <description>121. Best Time to Buy and Sell Stock  題目  給一個陣列代表每日股票的買賣價格，找出最好的買點與賣點。
 範例  Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0.</description>
    </item>
    
    <item>
      <title>Intersection of Two Arrays II</title>
      <link>https://mindbreaker3310.github.io/posts/intersection-of-two-arrays/</link>
      <pubDate>Wed, 20 Oct 2021 20:33:59 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/intersection-of-two-arrays/</guid>
      <description>350. Intersection of Two Arrays II  題目  給兩個陣列，找出這兩個陣列都有的數值，結果不需按照順序。
 範例  Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted.  解答  public class Solution { public int[] Intersect(int[] nums1, int[] nums2) { Array.Sort(nums1); Array.Sort(nums2); List&amp;lt;int&amp;gt; ansList = new List&amp;lt;int&amp;gt;(); int p1 = 0; int p2 = 0; while (p1 &amp;lt; nums1.Length &amp;amp;&amp;amp; p2 &amp;lt; nums2.</description>
    </item>
    
    <item>
      <title>Two Sum II | Input array is sorted</title>
      <link>https://mindbreaker3310.github.io/posts/two-sum-2/</link>
      <pubDate>Wed, 20 Oct 2021 20:30:23 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/two-sum-2/</guid>
      <description>167. Two Sum II - Input array is sorted  題目  給一個排序過的整數陣列與目標數，找出陣列中的兩個數值相加會等於目標數，並回傳這兩個數分別是第幾個數AKA index+1。
只會有一個解，且不同重複使用相同的元素
 範例  Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2.  解答  public class Solution { public int[] TwoSum(int[] numbers, int target) { int low = 0; int high = numbers.</description>
    </item>
    
    <item>
      <title>Move Zeroes</title>
      <link>https://mindbreaker3310.github.io/posts/move-zeroes/</link>
      <pubDate>Wed, 20 Oct 2021 20:27:32 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/move-zeroes/</guid>
      <description>283. Move Zeroes  題目  ‎給一個陣列，把所有0都丟掉最後面。
 範例  Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Input: nums = [0] Output: [0]  解答  public class Solution { public void MoveZeroes(int[] nums) { int p = 0; for (int i = 0; i &amp;lt; nums.Length; i++) { if (nums[i] != 0) { int temp = nums[p]; nums[p] = nums[i]; nums[i] = temp; } if (nums[p] != 0) { p++; } } } }  解題思路  兩個指標i、p，i每個次都會前進一步，遍歷整個陣列。p代表0的index位置，當nums[i]是0的時候p將不會跟著增加，等nums[i]不是0的時候，與其互換。</description>
    </item>
    
    <item>
      <title>Rotate Array</title>
      <link>https://mindbreaker3310.github.io/posts/rotate-array/</link>
      <pubDate>Tue, 19 Oct 2021 20:11:06 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/rotate-array/</guid>
      <description>189. Rotate Array  題目  ‎給一個陣列，將陣列向右旋轉k步。
 範例  Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100]  解答  public class Solution { public void Rotate(int[] nums, int k) { if (nums.</description>
    </item>
    
    <item>
      <title>Squares of a Sorted Array</title>
      <link>https://mindbreaker3310.github.io/posts/squares-of-a-sorted-array/</link>
      <pubDate>Tue, 19 Oct 2021 20:07:04 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/squares-of-a-sorted-array/</guid>
      <description>977. Squares of a Sorted Array  題目  給一個由排序到大的陣列，回傳每個數值都平方的排序陣列。
 範例  Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121]  解答  public class Solution { public int[] SortedSquares(int[] nums) { int[] ans = new int[nums.Length]; int i = 0; int j = nums.Length - 1; int p = j; while (i &amp;lt;= j) { if (Math.</description>
    </item>
    
    <item>
      <title>Merge Sorted Array</title>
      <link>https://mindbreaker3310.github.io/posts/merge-sorted-array/</link>
      <pubDate>Tue, 19 Oct 2021 20:03:08 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/merge-sorted-array/</guid>
      <description>88. Merge Sorted Array  題目  給予兩個非零部分由小到大排序的陣列nums1與nums2，m與n分別代表前面兩個陣列的長度。
目標要將nums1與nums2合併，替換掉nums1內的0。
 範例  Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and [].</description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>https://mindbreaker3310.github.io/posts/two-sum/</link>
      <pubDate>Tue, 19 Oct 2021 20:00:03 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/two-sum/</guid>
      <description>1. Two Sum  題目  給一整數陣列與目標數，找出陣列中的兩個數值相加會等於目標數，並回傳這兩個數的index。
只會有一個解，且不同重複使用相同的元素
 範例  Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Input: nums = [3,2,4], target = 6 Output: [1,2]  解答  public class Solution { public int[] TwoSum(int[] nums, int target) { Dictionary&amp;lt;int, int&amp;gt; dict = new Dictionary&amp;lt;int, int&amp;gt;(); for (int i = 0; i &amp;lt; nums.Length; i++) { if (dict.</description>
    </item>
    
    <item>
      <title>First Bad Version</title>
      <link>https://mindbreaker3310.github.io/posts/first-bad-version/</link>
      <pubDate>Tue, 19 Oct 2021 13:26:30 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/first-bad-version/</guid>
      <description>278. First Bad Version  題目  ‎給一個整數陣列，找到&amp;quot;連續&amp;quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。
 範例  Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -&amp;gt; false call isBadVersion(5) -&amp;gt; true call isBadVersion(4) -&amp;gt; true Then 4 is the first bad version. Input: n = 1, bad = 1 Output: 1  解答  public class Solution : VersionControl { public int FirstBadVersion(int n) { for (int i = n; i &amp;gt;= 1; i--) { if (!</description>
    </item>
    
    <item>
      <title>Maximum Subarray</title>
      <link>https://mindbreaker3310.github.io/posts/maximum-subarray/</link>
      <pubDate>Tue, 19 Oct 2021 12:31:43 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/maximum-subarray/</guid>
      <description>53. Maximum Subarray  題目  ‎給一個整數陣列，找到&amp;quot;連續&amp;quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。
 範例  Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6 Input: nums = [1] Output: 1  解答  public class Solution { public int MaxSubArray(int[] nums) { int currentSum = 0; int maxSum = nums[0]; for (int i = 0; i &amp;lt; nums.Length; i++) { currentSum += nums[i]; if (nums[i] &amp;gt; currentSum) { currentSum = nums[i]; } if (currentSum &amp;gt; maxSum) { maxSum = currentSum; } } return maxSum; } }  筆記  currentSum代表從前面往後加的總和，如果當nums[i]比前面加的總和還大時，那就從nums[i]開始重加currentSum = nums[i]</description>
    </item>
    
    <item>
      <title>Contains Duplicate</title>
      <link>https://mindbreaker3310.github.io/posts/contains-duplicate/</link>
      <pubDate>Tue, 19 Oct 2021 11:51:58 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/contains-duplicate/</guid>
      <description>217. Contains Duplicate  題目  給一整數陣列，如果任何值在陣列中‎‎至少出現兩次‎‎，回傳true，否則回傳false。
 範例  Input: nums = [1,2,3,1] Output: true Input: nums = [1,2,3,4] Output: false  解答  public class Solution { public bool ContainsDuplicate(int[] nums) { Array.Sort(nums); for (int i = 0; i &amp;lt; nums.Length - 1; i++) { if (nums[i] == nums[i + 1]) { return true; } } return false; } }  筆記  很直覺，先排序好陣列後，若有連續兩個數字相同，及代表有數值重複出現。
 參考  https://leetcode.com/problems/contains-duplicate/</description>
    </item>
    
    <item>
      <title>Search Insert Pposition</title>
      <link>https://mindbreaker3310.github.io/posts/search-insert-position/</link>
      <pubDate>Mon, 18 Oct 2021 22:16:12 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/search-insert-position/</guid>
      <description>35. Search Insert Position  題目  ‎給一個整數陣列，找到&amp;quot;連續&amp;quot;的子陣列（包含至少一個數位），它擁有最大的數值總和，並將其回傳‎‎。
 範例  Input: nums = [1,3,5,6], target = 5 Output: 2 Input: nums = [1,3,5,6], target = 2 Output: 1  解答  public class Solution { public int SearchInsert(int[] nums, int target) { int low = 0; int high = nums.Length - 1; while (low &amp;lt;= high) { int mid = low + (high - low) / 2; if (nums[mid] == target) { return mid; } else if (nums[mid] &amp;lt; target) { low = mid + 1; } else if (nums[mid] &amp;gt; target) { high = mid - 1; } } return low; } }  筆記  基本上與Binary Search的用法沒有區別，只差在return low的原因是當low &amp;lt;= high時，low的位置剛好會在target應該要在的位置上。</description>
    </item>
    
    <item>
      <title>Binary search algorithm</title>
      <link>https://mindbreaker3310.github.io/posts/binary-serarch/</link>
      <pubDate>Mon, 18 Oct 2021 20:10:11 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/binary-serarch/</guid>
      <description>704. Binary Search  題目  給一個由小到大排序的整數陣列nums與一個目標整數target，如果target存在於nums之中，回傳該目標數的index，否則回傳-1。
時間複雜度必須為O(log n)。
 範例  Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1  解答  public class Solution { public int Search(int[] nums, int target) { int low = 0; int high = nums.</description>
    </item>
    
  </channel>
</rss>
