<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on MindBreaker3310</title>
    <link>https://mindbreaker3310.github.io/post/</link>
    <description>Recent content in Posts on MindBreaker3310</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 09 Dec 2021 13:29:52 +0800</lastBuildDate><atom:link href="https://mindbreaker3310.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>刀劍神域Progressive 無星夜的詠嘆調 劇場版</title>
      <link>https://mindbreaker3310.github.io/posts/post/20211207_%E5%88%80%E5%8A%8D%E7%A5%9E%E5%9F%9Fprogressive.md/</link>
      <pubDate>Thu, 09 Dec 2021 13:29:52 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/20211207_%E5%88%80%E5%8A%8D%E7%A5%9E%E5%9F%9Fprogressive.md/</guid>
      <description>刀劍神域 無星夜的詠嘆調 劇場版  心得(小雷)  沒想到刀劍神域又出劇場版了，我好興奮啊!!上一次看序列爭戰我還在高雄念書，特別跑去市區超遠的高雄大遠百看4dx，那次也是我第一次體驗4dx的威力，那個動態座椅讓我完全融入在畫面裡面，刀刀砍在背上的感覺，刀削的氣流在耳邊噴發，我現在還在激動啊！總之就是回不去了，當時學生票好像是450還500有點忘記了，這個價錢對於學生的我也是不小的金額，但我還是覺得超值得。
這次去看的電影院是信義威秀，看了一下票價原價要550，這個票價也不是鬧著玩的，身為半個客家人的我，發現蝦皮上面有在賣威秀的招待票一張300元，而且可以看4dx，立馬下定，相見恨晚，太划算了。
刀劍神域Progressive是以亞絲娜作為故事主角出發，講述了進入SAO的原因及第一層的故事，本傳後面出了一堆遊戲但還是沒有比SAO更刺激好看，這個冷飯，真香。劇情還是有做一些修改與本傳不同，多了米特這個角色，她與亞絲娜從最好的朋友，遇到死結時選擇退出隊伍自己離開，到最後互相體諒和好，並走上各自的道路，完美呼應主題曲『前行』的歌詞。
中間一定要加上桐老爺出來裝逼，帥氣收割一波，整體畫面跟音樂我都很滿意，再加上動態座椅的加持，滿分10分我給9.5分，要是能有60FPS那就完美了，2022年也要出另一部劇場版，沒意外也要看4dx!</description>
    </item>
    
    <item>
      <title>指數投資</title>
      <link>https://mindbreaker3310.github.io/posts/post/20211206_%E6%8C%87%E6%95%B8%E6%8A%95%E8%B3%87.md/</link>
      <pubDate>Mon, 06 Dec 2021 10:55:10 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/20211206_%E6%8C%87%E6%95%B8%E6%8A%95%E8%B3%87.md/</guid>
      <description>指數投資  前情提要  在過去學生時期的時候就接觸了股票，總覺得要錢滾錢才能財富自由，把打工的錢都拿去玩看看，當時的選股策略是
1.股價夠低(因為本金太小買不起太貴的股票，每一次買股票都是All in)
2.看起來現在在低檔，低到不能再低的感覺
當時All in買了陽明4塊多還5塊，沒過幾天不知怎麼就噴到漲停，抓到一個低買高賣的節奏，沒多久就把它出清了，獲利4000$多，後來又聽朋友建議去買光學鏡頭股玉晶光，也賺了好幾千，我該不會其實很適合玩股票吧XD，直到我膝蓋中了一箭，南亞科賠20000元，沒想到那麼慘，之後就退出股海了。
直到現在全球股市一直突破新高，並且出社會領薪水的時候，我，再次回歸！等等這不會是高點的訊號吧QQ
 啟蒙  領了薪水後，只能說錢真的賺，現在年輕人基本上沒什麼希望，光活著就已經費盡全力，每週40小時的生命賣給公司，扣掉基本開銷、房租、伙食，可以花的錢也就一萬多吧，還沒有任何娛樂，活著，卻像是個死人，但想到父母為了我也把自己的生命販賣給公司，只為了能讓我有好的生活，我又有什麼好藉口不去努力呢？
看了一本關於理財的書籍『我用死薪水輕鬆理財賺千萬』，讓我了解的資產配置、再平衡與指數投資的基本概念，書中的內容都淺顯易懂，沒有什麼難以離解的東西。之後也看了網路上許多的文章與影片，清流君、魯爸、yp筆記、多拉王與伯格頭投資指南，都讓我堅信指數投資是個GOOD SHIT~
 伯格頭的投資指南
 evelop a workable plan Invest early and ofter Never bear too much or too little risk Diversify Never try to time the market Use index funds when possible Keep costs low Minimize taxes Invest with simplicity Stay the course    開戶準備  伯格頭的投資指南第7條，Keep costs low，盡可能地減少投資成本。
成本最低的應該是台股定期定額(新光證券20000內，手續費1元)
海外複委託美股(富邦證券，0.12%，低消12美金)
海外複委託英股(富邦證券，0.15%，低消15美金)</description>
    </item>
    
    <item>
      <title>Clean Architecture</title>
      <link>https://mindbreaker3310.github.io/posts/post/2021202_clean_architecture.md/</link>
      <pubDate>Thu, 02 Dec 2021 15:52:49 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/2021202_clean_architecture.md/</guid>
      <description>Clean Architecture  介紹  工作一陣子了，維護的系統也已經熟悉的許多了，但還有許多前人的智慧，一時之間是很難理解的XD，這時有一個乾淨的架構，或許上手的時間就可以更短了。
 一步步紀錄  建立一個訂單系統使用Clean Architecture
依照分層創建各個不同的Project， Ordering.API Ordering.Domain Ordering.Application Ordering.infrastructure
建立相依關係Project右鍵 &amp;gt;&amp;gt; Add &amp;gt;&amp;gt; Reference 相依關係
 開發Ordering.Domain Layer  我們要先建立兩個資料夾Common、Entities
Common 其中Common放的是我們建立Entity的基礎，含有兩個abstract class，EntityBase、ValueObject，
public abstract class EntityBase { public int Id { get; protected set; } public string CreatedBy { get; set; } public DateTime CreatedDate { get; set; } public string LastModifiedBy { get; set; } public DateTime? LastModifiedDate { get; set; } } 詳細定義與設計可以參考</description>
    </item>
    
    <item>
      <title>CQRS</title>
      <link>https://mindbreaker3310.github.io/posts/post/2021201_cqrs.md/</link>
      <pubDate>Wed, 01 Dec 2021 11:08:44 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/2021201_cqrs.md/</guid>
      <description>CQRS  筆記  CQRS(Command Query Responsibility Segregation)命令查詢分隔，目前看起來就是不再需要IRepository了，把它拆成Command(負責寫入資料庫的部分)與Query(只負責讀取的部分)。
可以增加資料庫的效能，Command的部分則會透過event的形式記錄起來再同步到DB上面。
我還是偏好原本的方法啊XD
 參考  https://ithelp.ithome.com.tw/articles/10237458</description>
    </item>
    
    <item>
      <title>Domain Driven Design 領域驅動設計</title>
      <link>https://mindbreaker3310.github.io/posts/post/2021130_ddd.md/</link>
      <pubDate>Tue, 30 Nov 2021 14:30:40 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/2021130_ddd.md/</guid>
      <description>Domain Driven Design  關於DDD  隨著科技進步，需求也是越來越複雜，更多的是需要專業領域人員與開發人員共同協作
DDD是一種基於領域知識來解決複雜業務問題的軟體開發方法論。
 Ubiquitous Language  使用通用語言就很重要了，講人話，減少溝通成本。 ex:下訂單大家就聽得懂，別講些什麼call Order API、B2C之類的
 Anemic Model  Anemic Model貧血模型是指那些只有getter、setter沒有行為能力的模型
LF2邪鬼(地獄火焰)防下功+防上跳+防前跳+防下跳+防上功 為例
Devil Max = new Devil(); //使用地獄火焰 Max.Defence().Down().Attack(); Max.Defence().Up().Jump(); Max.Defence().Left().Jump(); Max.Defence().Down().Jump(); Max.Defence().Up().Attack(); 導入DDD與專家討論過後，未來開發的人員直接看程式碼也看得懂在幹嘛
Devil Max = new Devil(); Max.HellFire();  與微服務的關係  很多時候Micorservices不知道怎麼做切割，這時候DDD就提供一個很好的方向去做業務分割。
 參考  https://ithelp.ithome.com.tw/articles/10216645 https://forum.gamer.com.tw/C.php?bsn=7648&amp;snA=3299</description>
    </item>
    
    <item>
      <title>SOLID、SoC</title>
      <link>https://mindbreaker3310.github.io/posts/post/2021129_solid%E5%8E%9F%E5%89%87.md/</link>
      <pubDate>Mon, 29 Nov 2021 16:10:40 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/2021129_solid%E5%8E%9F%E5%89%87.md/</guid>
      <description>SOLID、SoC  SOLID原則  Single responsibility principle 單一功能原則 認為一個class就應該只有一個任務要做，不做其他任務以外的事情，過去是很多不同的需求都用同一個Service，單一功能原則則是提供各種不同的Use Case給各個需求。 SRP示意圖
Open/ closed principle 開閉原則 一個class或Function對於他的擴展是開放的，但是對於修改是封閉的，意思就是不改變他的行為，但是可以增加新的功能。 就像是電動理髮刀，可以換上各種不同的刀頭(擴展)，但是機身本體是不能修改的(封閉)。
Liskov substitution principle 里氏替換原則 程式中的物件應該是可以在不改變正確性的前提下被他的子類所替換的概念，我們在使用「繼承」時，重要的是重複使用 (reuse) 已經寫好的行為，而不是將所有繼承的行為全部覆蓋。
Interface segregation principle 介面隔離原則 很多個客製化的interface比一個通用的interface還要來得更好管理，例如一個政客interface有提出政見()、拜票()、努力工作()，但事實上不是每一個政客都想實作努力工作XD，所以應該方別建兩個interface，政客介面:提出政見()、拜票()與工作介面:努力工作()。
Dependency inversion principle 依賴反轉原則 各個class之間的相依性應該越低越好，上層的class不該依賴下層的class DIP示意圖
 SoC(Separation of concerns) 關注點分離  關注點分離表示，以前端的例子來說，在過去我們是以「關注技術」的方式來分離成HTML、CSS、JavaScript，現今主流框架Vue則是採用「關注元件」的方式來分離，每一個Component都有各自的HTML、CSS、JavaScript。
 參考  https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1) https://medium.com/@f40507777/%E9%96%8B%E6%94%BE%E5%B0%81%E9%96%89%E5%8E%9F%E5%89%87-open-closed-principle-31d61f9d37a5 https://medium.com/%E6%89%8B%E5%AF%AB%E7%AD%86%E8%A8%98/%E7%AC%AC-10-%E7%AB%A0-%E9%A1%9E%E5%88%A5-clean-code-1c7898d11cd7</description>
    </item>
    
    <item>
      <title>使用Grpc服務</title>
      <link>https://mindbreaker3310.github.io/posts/post/2021125_%E4%BD%BF%E7%94%A8grpc%E6%9C%8D%E5%8B%99.md/</link>
      <pubDate>Thu, 25 Nov 2021 15:57:43 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/2021125_%E4%BD%BF%E7%94%A8grpc%E6%9C%8D%E5%8B%99.md/</guid>
      <description>使用Grpc服務  前情提要  購物車的功能需要導入折價券.Grpc的服務
購物車是Client端
折價券是Server端
 新增Grpc服務的reference  VS for Mac在專案下面就可以直接看到Connected Services Windows則是右鍵 &amp;raquo; Add &amp;raquo; connected services
選取購物車專案的connected services &amp;raquo; Add new Grpc service reference &amp;raquo; Add &amp;raquo; 參照折價券.Grpc裡面的.proto &amp;raquo; 選擇Client模式
執行完後，可以看到.csproj多了Grpc服務、專案下也多了protos
&amp;lt;Protobuf Include=&amp;#34;..\..\Discount\Discount.Grpc\Discount.Grpc\Protos\discount.proto&amp;#34; GrpcServices=&amp;#34;Client&amp;#34;&amp;gt; &amp;lt;OutputDir&amp;gt;obj\Debug\net5.0\&amp;lt;/OutputDir&amp;gt; &amp;lt;Link&amp;gt;Protos\discount.proto&amp;lt;/Link&amp;gt; &amp;lt;/Protobuf&amp;gt; 建置專案後，也會產生ProtoServiceClient等cs檔
 參考  https://pjchender.dev/golang/grpc-getting-started/ https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-6.0&amp;tabs=visual-studio</description>
    </item>
    
    <item>
      <title>AutoMapper - DI Version</title>
      <link>https://mindbreaker3310.github.io/posts/post/20211125_automapper.md/</link>
      <pubDate>Thu, 25 Nov 2021 14:55:07 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/20211125_automapper.md/</guid>
      <description>AutoMapper 筆記  簡單介紹  可以輕鬆的轉換兩個class，讓程式碼變得更加簡短乾淨。
 範例  message CouponModel { int32 id = 1; string productName = 2; string description = 3; int32 amount = 4; } 在Grpc定義的優戶券模型
public class Coupon { public int Id { get; set; } public string ProductName { get; set; } public string Description { get; set; } public int Amount { get; set; } } 我們自己定義的模型
原先轉換需要像是這個樣子
Coupon coupon; CouponModel cm = new CouponModel{ id = coupon.</description>
    </item>
    
    <item>
      <title>Grpc 筆記</title>
      <link>https://mindbreaker3310.github.io/posts/post/20211124_grpcmemo.md/</link>
      <pubDate>Wed, 24 Nov 2021 10:12:35 +0800</pubDate>
      
      <guid>https://mindbreaker3310.github.io/posts/post/20211124_grpcmemo.md/</guid>
      <description>Grpc 筆記  簡單介紹  Grpc是google開發的rpc(Remote Procedure Call)框架，用於電腦與電腦之間的溝通，就像電腦A呼叫電腦B做事情，電腦B做好事情後把結果回傳給電腦A，與一般的api不同的地方在於，電腦A、B在進行Grpc溝通前，都必須有protocal buffers檔案來把格式與方法定義清楚，並使用HTTP/2進行傳輸，快速、低延遲、支持串流。
 protocal buffers 檔案  syntax = &amp;#34;proto3&amp;#34;;//使用的protocal buffers版本  option csharp_namespace = &amp;#34;MyFirstGrpc.Grpc&amp;#34;;//命名空間  package greeter; // 定義交換資料的格式 message HelloRequest { string name = 1; } // 定義交換資料的格式 message HelloReply { string message = 1; } // 定義呼叫api的方法 service Greeter { // SayHello方法需要輸入參數(HelloRequest格式) 會回傳(HelloReply格式)  rpc SayHello (HelloRequest) returns (HelloReply); }  AppSettings 使用Http2  { &amp;#34;Logging&amp;#34;: { &amp;#34;LogLevel&amp;#34;: { &amp;#34;Default&amp;#34;: &amp;#34;Information&amp;#34;, &amp;#34;Microsoft&amp;#34;: &amp;#34;Warning&amp;#34;, &amp;#34;Microsoft.</description>
    </item>
    
  </channel>
</rss>
